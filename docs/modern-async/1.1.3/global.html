<!DOCTYPE html><html lang="en" style="font-size:16px"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="author" content="Nicolas Vanhoren"><meta name="description" content="A modern tooling library for asynchronous operations using async/await and promises"><script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" integrity="sha256-9/aliU8dGd2tb6OSsuzixeV4y/faTqgFtohetphbbj0=" crossorigin="anonymous"></script><script src="https://cdn.jsdelivr.net/npm/vue@2.6.12/dist/vue.min.js" integrity="sha256-KSlsysqp7TXtFo/FHjb1T9b425x3hrvzjMWaJyKbpcI=" crossorigin="anonymous"></script><script src="https://cdn.jsdelivr.net/npm/axios@0.21.0/dist/axios.min.js" integrity="sha256-OPn1YfcEh9W2pwF1iSS+yDk099tYj+plSrCS6Esa9NA=" crossorigin="anonymous"></script><script src="../../inject-script.js"></script><script src="https://www.googletagmanager.com/gtag/js?id=G-707LQFBQY9"></script><script src="../../ga.js"></script><script src="https://cdn.jsdelivr.net/npm/modern-async"></script><title>Global</title><!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]--><script src="scripts/third-party/hljs.js" defer="defer"></script><script src="scripts/third-party/hljs-line-num.js" defer="defer"></script><script src="scripts/third-party/popper.js" defer="defer"></script><script src="scripts/third-party/tippy.js" defer="defer"></script><script src="scripts/third-party/tocbot.min.js"></script><script>var baseURL="/",locationPathname="",baseURL=(locationPathname=document.location.pathname).substr(0,locationPathname.lastIndexOf("/")+1)</script><link rel="stylesheet" href="styles/clean-jsdoc-theme.min.css"><svg aria-hidden="true" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" style="display:none"><defs><symbol id="copy-icon" viewbox="0 0 488.3 488.3"><g><path d="M314.25,85.4h-227c-21.3,0-38.6,17.3-38.6,38.6v325.7c0,21.3,17.3,38.6,38.6,38.6h227c21.3,0,38.6-17.3,38.6-38.6V124    C352.75,102.7,335.45,85.4,314.25,85.4z M325.75,449.6c0,6.4-5.2,11.6-11.6,11.6h-227c-6.4,0-11.6-5.2-11.6-11.6V124    c0-6.4,5.2-11.6,11.6-11.6h227c6.4,0,11.6,5.2,11.6,11.6V449.6z"/><path d="M401.05,0h-227c-21.3,0-38.6,17.3-38.6,38.6c0,7.5,6,13.5,13.5,13.5s13.5-6,13.5-13.5c0-6.4,5.2-11.6,11.6-11.6h227    c6.4,0,11.6,5.2,11.6,11.6v325.7c0,6.4-5.2,11.6-11.6,11.6c-7.5,0-13.5,6-13.5,13.5s6,13.5,13.5,13.5c21.3,0,38.6-17.3,38.6-38.6    V38.6C439.65,17.3,422.35,0,401.05,0z"/></g></symbol><symbol id="search-icon" viewBox="0 0 512 512"><g><g><path d="M225.474,0C101.151,0,0,101.151,0,225.474c0,124.33,101.151,225.474,225.474,225.474    c124.33,0,225.474-101.144,225.474-225.474C450.948,101.151,349.804,0,225.474,0z M225.474,409.323    c-101.373,0-183.848-82.475-183.848-183.848S124.101,41.626,225.474,41.626s183.848,82.475,183.848,183.848    S326.847,409.323,225.474,409.323z"/></g></g><g><g><path d="M505.902,476.472L386.574,357.144c-8.131-8.131-21.299-8.131-29.43,0c-8.131,8.124-8.131,21.306,0,29.43l119.328,119.328    c4.065,4.065,9.387,6.098,14.715,6.098c5.321,0,10.649-2.033,14.715-6.098C514.033,497.778,514.033,484.596,505.902,476.472z"/></g></g></symbol><symbol id="font-size-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M11.246 15H4.754l-2 5H.6L7 4h2l6.4 16h-2.154l-2-5zm-.8-2L8 6.885 5.554 13h4.892zM21 12.535V12h2v8h-2v-.535a4 4 0 1 1 0-6.93zM19 18a2 2 0 1 0 0-4 2 2 0 0 0 0 4z"/></symbol><symbol id="add-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M11 11V5h2v6h6v2h-6v6h-2v-6H5v-2z"/></symbol><symbol id="minus-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M5 11h14v2H5z"/></symbol><symbol id="dark-theme-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M10 7a7 7 0 0 0 12 4.9v.1c0 5.523-4.477 10-10 10S2 17.523 2 12 6.477 2 12 2h.1A6.979 6.979 0 0 0 10 7zm-6 5a8 8 0 0 0 15.062 3.762A9 9 0 0 1 8.238 4.938 7.999 7.999 0 0 0 4 12z"/></symbol><symbol id="light-theme-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M12 18a6 6 0 1 1 0-12 6 6 0 0 1 0 12zm0-2a4 4 0 1 0 0-8 4 4 0 0 0 0 8zM11 1h2v3h-2V1zm0 19h2v3h-2v-3zM3.515 4.929l1.414-1.414L7.05 5.636 5.636 7.05 3.515 4.93zM16.95 18.364l1.414-1.414 2.121 2.121-1.414 1.414-2.121-2.121zm2.121-14.85l1.414 1.415-2.121 2.121-1.414-1.414 2.121-2.121zM5.636 16.95l1.414 1.414-2.121 2.121-1.414-1.414 2.121-2.121zM23 11v2h-3v-2h3zM4 11v2H1v-2h3z"/></symbol><symbol id="reset-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M18.537 19.567A9.961 9.961 0 0 1 12 22C6.477 22 2 17.523 2 12S6.477 2 12 2s10 4.477 10 10c0 2.136-.67 4.116-1.81 5.74L17 12h3a8 8 0 1 0-2.46 5.772l.997 1.795z"/></symbol><symbol id="down-icon" viewBox="0 0 16 16"><path fill-rule="evenodd" clip-rule="evenodd" d="M12.7803 6.21967C13.0732 6.51256 13.0732 6.98744 12.7803 7.28033L8.53033 11.5303C8.23744 11.8232 7.76256 11.8232 7.46967 11.5303L3.21967 7.28033C2.92678 6.98744 2.92678 6.51256 3.21967 6.21967C3.51256 5.92678 3.98744 5.92678 4.28033 6.21967L8 9.93934L11.7197 6.21967C12.0126 5.92678 12.4874 5.92678 12.7803 6.21967Z"></path></symbol><symbol id="codepen-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M16.5 13.202L13 15.535v3.596L19.197 15 16.5 13.202zM14.697 12L12 10.202 9.303 12 12 13.798 14.697 12zM20 10.869L18.303 12 20 13.131V10.87zM19.197 9L13 4.869v3.596l3.5 2.333L19.197 9zM7.5 10.798L11 8.465V4.869L4.803 9 7.5 10.798zM4.803 15L11 19.131v-3.596l-3.5-2.333L4.803 15zM4 13.131L5.697 12 4 10.869v2.262zM2 9a1 1 0 0 1 .445-.832l9-6a1 1 0 0 1 1.11 0l9 6A1 1 0 0 1 22 9v6a1 1 0 0 1-.445.832l-9 6a1 1 0 0 1-1.11 0l-9-6A1 1 0 0 1 2 15V9z"/></symbol><symbol id="close-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M12 10.586l4.95-4.95 1.414 1.414-4.95 4.95 4.95 4.95-1.414 1.414-4.95-4.95-4.95 4.95-1.414-1.414 4.95-4.95-4.95-4.95L7.05 5.636z"/></symbol><symbol id="menu-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M3 4h18v2H3V4zm0 7h18v2H3v-2zm0 7h18v2H3v-2z"/></symbol></defs></svg></head><body class="dark" data-theme="dark"><div class="sidebar-container"><div class="sidebar" id="sidebar"><a href="/" class="sidebar-title sidebar-title-anchor">modern-async</a><div class="sidebar-items-container"><div class="sidebar-section-title with-arrow" data-isopen="false" id="bqr_fCmM1c_Z4NxD1P5CB"><div>Classes</div><svg><use xlink:href="#down-icon"></use></svg></div><div class="sidebar-section-children-container"><div class="sidebar-section-children"><a href="CancelledError.html">CancelledError</a></div><div class="sidebar-section-children"><a href="Deferred.html">Deferred</a></div><div class="sidebar-section-children"><a href="Delayer.html">Delayer</a></div><div class="sidebar-section-children"><a href="Queue.html">Queue</a></div><div class="sidebar-section-children"><a href="Scheduler.html">Scheduler</a></div><div class="sidebar-section-children"><a href="TimeoutError.html">TimeoutError</a></div></div><div class="sidebar-section-title with-arrow" data-isopen="false" id="y--SulyMBf_mP5QBQSbgu"><div>Global</div><svg><use xlink:href="#down-icon"></use></svg></div><div class="sidebar-section-children-container"><div class="sidebar-section-children"><a href="global.html#asyncIterableWrap">asyncIterableWrap</a></div><div class="sidebar-section-children"><a href="global.html#asyncRoot">asyncRoot</a></div><div class="sidebar-section-children"><a href="global.html#asyncWrap">asyncWrap</a></div><div class="sidebar-section-children"><a href="global.html#delay">delay</a></div><div class="sidebar-section-children"><a href="global.html#delayCancellable">delayCancellable</a></div><div class="sidebar-section-children"><a href="global.html#every">every</a></div><div class="sidebar-section-children"><a href="global.html#everyLimit">everyLimit</a></div><div class="sidebar-section-children"><a href="global.html#everySeries">everySeries</a></div><div class="sidebar-section-children"><a href="global.html#filter">filter</a></div><div class="sidebar-section-children"><a href="global.html#filterGenerator">filterGenerator</a></div><div class="sidebar-section-children"><a href="global.html#filterLimit">filterLimit</a></div><div class="sidebar-section-children"><a href="global.html#filterSeries">filterSeries</a></div><div class="sidebar-section-children"><a href="global.html#find">find</a></div><div class="sidebar-section-children"><a href="global.html#findIndex">findIndex</a></div><div class="sidebar-section-children"><a href="global.html#findIndexLimit">findIndexLimit</a></div><div class="sidebar-section-children"><a href="global.html#findIndexSeries">findIndexSeries</a></div><div class="sidebar-section-children"><a href="global.html#findLimit">findLimit</a></div><div class="sidebar-section-children"><a href="global.html#findSeries">findSeries</a></div><div class="sidebar-section-children"><a href="global.html#forEach">forEach</a></div><div class="sidebar-section-children"><a href="global.html#forEachLimit">forEachLimit</a></div><div class="sidebar-section-children"><a href="global.html#forEachSeries">forEachSeries</a></div><div class="sidebar-section-children"><a href="global.html#map">map</a></div><div class="sidebar-section-children"><a href="global.html#mapGenerator">mapGenerator</a></div><div class="sidebar-section-children"><a href="global.html#mapLimit">mapLimit</a></div><div class="sidebar-section-children"><a href="global.html#mapSeries">mapSeries</a></div><div class="sidebar-section-children"><a href="global.html#queueMicrotask">queueMicrotask</a></div><div class="sidebar-section-children"><a href="global.html#reduce">reduce</a></div><div class="sidebar-section-children"><a href="global.html#reduceRight">reduceRight</a></div><div class="sidebar-section-children"><a href="global.html#sleep">sleep</a></div><div class="sidebar-section-children"><a href="global.html#sleepCancellable">sleepCancellable</a></div><div class="sidebar-section-children"><a href="global.html#sleepPrecise">sleepPrecise</a></div><div class="sidebar-section-children"><a href="global.html#sleepPreciseCancellable">sleepPreciseCancellable</a></div><div class="sidebar-section-children"><a href="global.html#some">some</a></div><div class="sidebar-section-children"><a href="global.html#someLimit">someLimit</a></div><div class="sidebar-section-children"><a href="global.html#someSeries">someSeries</a></div><div class="sidebar-section-children"><a href="global.html#timeout">timeout</a></div><div class="sidebar-section-children"><a href="global.html#timeoutPrecise">timeoutPrecise</a></div><div class="sidebar-section-children"><a href="global.html#toArray">toArray</a></div></div></div></div></div><div class="navbar-container" id="VuAckcnZhf"><nav class="navbar"><div class="navbar-left-items"><div class="navbar-item"><a id="" href="https://github.com/nicolas-van/modern-async" target="">Github</a></div></div><div class="navbar-right-items"><div class="navbar-right-item"><button class="icon-button search-button" aria-label="open-search"><svg><use xlink:href="#search-icon"></use></svg></button></div><div class="navbar-right-item"><button class="icon-button theme-toggle" aria-label="toggle-theme"><svg><use class="theme-svg-use" xlink:href="#light-theme-icon"></use></svg></button></div><div class="navbar-right-item"><button class="icon-button font-size" aria-label="change-font-size"><svg><use xlink:href="#font-size-icon"></use></svg></button></div></div><nav></nav></nav></div><div class="toc-container"><div class="toc-content"><span class="bold">On this page</span><div id="eed4d2a0bfd64539bb9df78095dec881"></div></div></div><div class="body-wrapper"><div class="main-content"><div class="main-wrapper"><section><article><div class="container-overview"></div><h2 id="methods" class="subsection-title has-anchor">Methods</h2><h3 class="name has-anchor" id="asyncIterableWrap"><span class="type-signature">(async, generator) </span>asyncIterableWrap<span class="signature">(iterable)</span><span class="type-signature"> &rarr; {any}</span></h3><div class="description"><p>Wraps an iterable or async iterable into an iterable that is guaranted to be async.</p></div><div class="method-member-container flex flex-col w-100 overflow-auto mt-20"><strong>Parameters:</strong><table class="params"><thead><tr><th>Name</th><th>Type</th><th class="last">Description</th></tr></thead><tbody><tr><td class="name"><code>iterable</code></td><td class="type"><span class="param-type">Iterable</span> |<wbr> <span class="param-type">AsyncIterable</span></td><td class="description last"><p>An iterable or async iterable object.</p></td></tr></tbody></table></div><dl class="details"><div class="details-item-container"><dt class="tag-source bold">Source</dt><dd class="tag-source"><ul><li><a href="asyncIterableWrap.mjs.html">asyncIterableWrap.mjs</a>, <a href="asyncIterableWrap.mjs.html#line27">line 27</a></li></ul></dd></div></dl><div class="method-member-container mt-20"><strong>Yields:</strong><div class="param-desc"><p>The elements returned by the original iterable.</p></div><dl class="param-type"><dt>Type:&nbsp;</dt><dd><span class="param-type">any</span></dd></dl></div><div class="method-member-container flex flex-col w-100 overflow-auto mt-20"><strong>Example</strong><div class="rel"><pre class="prettyprint"><code>import { asyncIterableWrap } from 'modern-async'

// example sync generator
function* syncGenerator() {
  for (let i = 0; i &lt; 3; i += 1) {
    yield i
  }
}

const asyncIterable = asyncIterableWrap(syncGenerator())

for await (const el of asyncIterable) {
  console.log(el)
}
// will print:
// 0
// 1
// 2</code></pre></div></div><h3 class="name has-anchor" id="asyncRoot"><span class="type-signature">(async) </span>asyncRoot<span class="signature">(fct, errorHandler<span class="signature-attributes">opt</span>)</span></h3><div class="description"><p>Immediately calls an asynchronous function and redirects to an error handler if it throws an exception. The error handler is optional, the default one just outputs the error in the console.</p><p>This function is trivial but useful when you can't use top-level await for compatibility reasons.</p></div><div class="method-member-container flex flex-col w-100 overflow-auto mt-20"><strong>Parameters:</strong><table class="params"><thead><tr><th>Name</th><th>Type</th><th>Attributes</th><th>Default</th><th class="last">Description</th></tr></thead><tbody><tr><td class="name"><code>fct</code></td><td class="type"><span class="param-type">function</span></td><td class="attributes"></td><td class="default"></td><td class="description last"><p>An asynchronous function to call.</p></td></tr><tr><td class="name"><code>errorHandler</code></td><td class="type"><span class="param-type">function</span></td><td class="attributes">&lt;optional><br></td><td class="default">null</td><td class="description last"><p>A facultative error handler. This function will receive a single argument: the thrown exception. The default behavior is to output the exception in the console.</p></td></tr></tbody></table></div><dl class="details"><div class="details-item-container"><dt class="tag-source bold">Source</dt><dd class="tag-source"><ul><li><a href="asyncRoot.mjs.html">asyncRoot.mjs</a>, <a href="asyncRoot.mjs.html#line23">line 23</a></li></ul></dd></div></dl><div class="method-member-container flex flex-col w-100 overflow-auto mt-20"><strong>Example</strong><div class="rel"><pre class="prettyprint"><code>import { asyncRoot } from 'modern-async'

asyncRoot(async () => {
  // any code using await
}, (e) => {
  console.error("An error occured", e)
  process.exit(-1)
})</code></pre></div></div><h3 class="name has-anchor" id="asyncWrap"><span class="type-signature"></span>asyncWrap<span class="signature">(fct)</span><span class="type-signature"> &rarr; {function}</span></h3><div class="description"><p>Wraps a function call that may be synchronous in a function that is guaranted to be async. This is a stricter version of calling a function and wrapping its result using <code>Promise.resolve()</code> as the new function also handles the case where the original function throws an exception.</p></div><div class="method-member-container flex flex-col w-100 overflow-auto mt-20"><strong>Parameters:</strong><table class="params"><thead><tr><th>Name</th><th>Type</th><th class="last">Description</th></tr></thead><tbody><tr><td class="name"><code>fct</code></td><td class="type"><span class="param-type">function</span></td><td class="description last"><p>The function to wrap.</p></td></tr></tbody></table></div><dl class="details"><div class="details-item-container"><dt class="tag-source bold">Source</dt><dd class="tag-source"><ul><li><a href="asyncWrap.mjs.html">asyncWrap.mjs</a>, <a href="asyncWrap.mjs.html#line23">line 23</a></li></ul></dd></div></dl><div class="method-member-container mt-20"><strong>Returns:</strong><div class="param-desc"><p>The wrapped function.</p></div><dl class="param-type"><dt>Type:&nbsp;</dt><dd><span class="param-type">function</span></dd></dl></div><div class="method-member-container flex flex-col w-100 overflow-auto mt-20"><strong>Example</strong><div class="rel"><pre class="prettyprint"><code>import { asyncWrap } from 'modern-async'

const myFunction = () => {
  // any kind of function that may or may not return a promise
}

const asyncFct = asyncWrap(myFunction)

const promise = asyncFct()
console.log(promise instanceof Promise) // prints true</code></pre></div></div><h3 class="name has-anchor" id="delay"><span class="type-signature">(async) </span>delay<span class="signature">()</span><span class="type-signature"> &rarr; {Promise.&lt;void>}</span></h3><div class="description"><p>A function returning a promise that will be resolved in a later task of the event loop.</p><p>This function uses core-js' shim for <code>setImmediate()</code> internally.</p></div><dl class="details"><div class="details-item-container"><dt class="tag-source bold">Source</dt><dd class="tag-source"><ul><li><a href="delay.mjs.html">delay.mjs</a>, <a href="delay.mjs.html#line17">line 17</a></li></ul></dd></div></dl><div class="method-member-container mt-20"><strong>Returns:</strong><div class="param-desc"><p>A promise that will be resolved on a later tick of the event loop.</p></div><dl class="param-type"><dt>Type:&nbsp;</dt><dd><span class="param-type">Promise.&lt;void></span></dd></dl></div><div class="method-member-container flex flex-col w-100 overflow-auto mt-20"><strong>Example</strong><div class="rel"><pre class="prettyprint"><code>import { delay } from 'modern-async'

console.log('this executes in a tick of the event loop')
await delay()
console.log('this executes in another tick of the event loop')</code></pre></div></div><h3 class="name has-anchor" id="delayCancellable"><span class="type-signature"></span>delayCancellable<span class="signature">()</span><span class="type-signature"> &rarr; {Array}</span></h3><div class="description"><p>A function returning a promise that will be resolved in a later tick of the event loop.</p><p>This function returns both a promise and cancel function in order to cancel the wait time if necessary. If cancelled, the promise will be rejected with a CancelledError.</p><p>This function uses core-js' shim for <code>setImmediate()</code> internally.</p></div><dl class="details"><div class="details-item-container"><dt class="tag-source bold">Source</dt><dd class="tag-source"><ul><li><a href="delayCancellable.mjs.html">delayCancellable.mjs</a>, <a href="delayCancellable.mjs.html#line30">line 30</a></li></ul></dd></div></dl><div class="method-member-container mt-20"><strong>Returns:</strong><div class="param-desc"><p>A tuple of two objects:</p><ul><li>The promise</li><li>The cancel function. It will return a boolean that will be true if the promise was effectively cancelled, false otherwise.</li></ul></div><dl class="param-type"><dt>Type:&nbsp;</dt><dd><span class="param-type">Array</span></dd></dl></div><div class="method-member-container flex flex-col w-100 overflow-auto mt-20"><strong>Example</strong><div class="rel"><pre class="prettyprint"><code>import { delayCancellable, CancelledError } from 'modern-async'

const [promise, cancel] = delayCancellable()
cancel()
try {
  await promise
} catch (e) {
  console.log(e instanceof CancelledError) // prints true
}</code></pre></div></div><h3 class="name has-anchor" id="every"><span class="type-signature">(async) </span>every<span class="signature">(iterable, iteratee)</span><span class="type-signature"> &rarr; {Promise.&lt;boolean>}</span></h3><div class="description"><p>Returns <code>true</code> if all elements of an iterable pass a truth test and <code>false</code> otherwise.</p><p>The iteratee will be run in parallel. If any truth test returns <code>false</code> the promise is immediately resolved.</p><p>In case of exception in one of the iteratee calls the promise returned by this function will be rejected with the exception. In the very specific case where a test returns <code>false</code> and an already started task throws an exception that exception will be plainly ignored.</p></div><div class="method-member-container flex flex-col w-100 overflow-auto mt-20"><strong>Parameters:</strong><table class="params"><thead><tr><th>Name</th><th>Type</th><th class="last">Description</th></tr></thead><tbody><tr><td class="name"><code>iterable</code></td><td class="type"><span class="param-type">Iterable</span> |<wbr> <span class="param-type">AsyncIterable</span></td><td class="description last"><p>An iterable or async iterable object.</p></td></tr><tr><td class="name"><code>iteratee</code></td><td class="type"><span class="param-type">function</span></td><td class="description last"><p>A function that will be called with each member of the iterable. It will receive three arguments:</p><ul><li><code>value</code>: The current value to process</li><li><code>index</code>: The index in the iterable. Will start from 0.</li><li><code>iterable</code>: The iterable on which the operation is being performed.</li></ul></td></tr></tbody></table></div><dl class="details"><div class="details-item-container"><dt class="tag-source bold">Source</dt><dd class="tag-source"><ul><li><a href="every.mjs.html">every.mjs</a>, <a href="every.mjs.html#line35">line 35</a></li></ul></dd></div></dl><div class="method-member-container mt-20"><strong>Returns:</strong><div class="param-desc"><p>A promise that will be resolved to <code>true</code> if all values pass the truth test and <code>false</code> if a least one of them doesn't pass it. That promise will be rejected if one of the truth test throws an exception.</p></div><dl class="param-type"><dt>Type:&nbsp;</dt><dd><span class="param-type">Promise.&lt;boolean></span></dd></dl></div><div class="method-member-container flex flex-col w-100 overflow-auto mt-20"><strong>Example</strong><div class="rel"><pre class="prettyprint"><code>import { every, sleep } from 'modern-async'

const array = [1, 2, 3]

const result = await every(array, async (v) => {
  // these calls will be performed in parallel
  await sleep(10) // waits 10ms
  return v > 0
})
console.log(result) // prints true
// total processing time should be ~ 10ms</code></pre></div></div><h3 class="name has-anchor" id="everyLimit"><span class="type-signature">(async) </span>everyLimit<span class="signature">(iterable, iteratee, queueOrConcurrency)</span><span class="type-signature"> &rarr; {Promise.&lt;boolean>}</span></h3><div class="description"><p>Returns <code>true</code> if all elements of an iterable pass a truth test and <code>false</code> otherwise.</p><p>The calls to <code>iteratee</code> will be performed in a queue to limit the concurrency of these calls. If any truth test returns <code>false</code> the promise is immediately resolved.</p><p>Whenever a test returns <code>false</code>, all the remaining tasks will be cancelled as long as they didn't started already. In case of exception in one of the iteratee calls the promise returned by this function will be rejected with the exception and the remaining pending tasks will also be cancelled. In the very specific case where a test returns <code>false</code> and an already started task throws an exception that exception will be plainly ignored.</p></div><div class="method-member-container flex flex-col w-100 overflow-auto mt-20"><strong>Parameters:</strong><table class="params"><thead><tr><th>Name</th><th>Type</th><th class="last">Description</th></tr></thead><tbody><tr><td class="name"><code>iterable</code></td><td class="type"><span class="param-type">Iterable</span> |<wbr> <span class="param-type">AsyncIterable</span></td><td class="description last"><p>An iterable or async iterable object.</p></td></tr><tr><td class="name"><code>iteratee</code></td><td class="type"><span class="param-type">function</span></td><td class="description last"><p>A function that will be called with each member of the iterable. It will receive three arguments:</p><ul><li><code>value</code>: The current value to process</li><li><code>index</code>: The index in the iterable. Will start from 0.</li><li><code>iterable</code>: The iterable on which the operation is being performed.</li></ul></td></tr><tr><td class="name"><code>queueOrConcurrency</code></td><td class="type"><span class="param-type"><a href="Queue.html">Queue</a></span> |<wbr> <span class="param-type">number</span></td><td class="description last"><p>If a queue is specified it will be used to schedule the calls to <code>iteratee</code>. If a number is specified it will be used as the concurrency of a Queue that will be created implicitly for the same purpose.</p></td></tr></tbody></table></div><dl class="details"><div class="details-item-container"><dt class="tag-source bold">Source</dt><dd class="tag-source"><ul><li><a href="everyLimit.mjs.html">everyLimit.mjs</a>, <a href="everyLimit.mjs.html#line45">line 45</a></li></ul></dd></div></dl><div class="method-member-container mt-20"><strong>Returns:</strong><div class="param-desc"><p>A promise that will be resolved to <code>true</code> if all values pass the truth test and <code>false</code> if a least one of them doesn't pass it. That promise will be rejected if one of the truth test throws an exception.</p></div><dl class="param-type"><dt>Type:&nbsp;</dt><dd><span class="param-type">Promise.&lt;boolean></span></dd></dl></div><div class="method-member-container flex flex-col w-100 overflow-auto mt-20"><strong>Example</strong><div class="rel"><pre class="prettyprint"><code>import { everyLimit, sleep } from 'modern-async'

const array = [1, 2, 3]

const result = await everyLimit(array, async (v) => {
  // these calls will be performed in parallel with a maximum of 2
  // concurrent calls
  await sleep(10) // waits 10ms
  return v > 0
}, 2)
console.log(result) // prints true
// total processing time should be ~ 20ms</code></pre></div></div><h3 class="name has-anchor" id="everySeries"><span class="type-signature">(async) </span>everySeries<span class="signature">(iterable, iteratee)</span><span class="type-signature"> &rarr; {Promise.&lt;boolean>}</span></h3><div class="description"><p>Returns <code>true</code> if all elements of an iterable pass a truth test and <code>false</code> otherwise.</p><p>The iteratee will be run sequentially. If any truth test returns <code>false</code> the promise is immediately resolved.</p><p>In case of exception in one of the iteratee calls the promise returned by this function will be rejected with the exception and the remaining pending tasks will be cancelled.</p></div><div class="method-member-container flex flex-col w-100 overflow-auto mt-20"><strong>Parameters:</strong><table class="params"><thead><tr><th>Name</th><th>Type</th><th class="last">Description</th></tr></thead><tbody><tr><td class="name"><code>iterable</code></td><td class="type"><span class="param-type">Iterable</span> |<wbr> <span class="param-type">AsyncIterable</span></td><td class="description last"><p>An iterable or async iterable object.</p></td></tr><tr><td class="name"><code>iteratee</code></td><td class="type"><span class="param-type">function</span></td><td class="description last"><p>A function that will be called with each member of the iterable. It will receive three arguments:</p><ul><li><code>value</code>: The current value to process</li><li><code>index</code>: The index in the iterable. Will start from 0.</li><li><code>iterable</code>: The iterable on which the operation is being performed.</li></ul></td></tr></tbody></table></div><dl class="details"><div class="details-item-container"><dt class="tag-source bold">Source</dt><dd class="tag-source"><ul><li><a href="everySeries.mjs.html">everySeries.mjs</a>, <a href="everySeries.mjs.html#line35">line 35</a></li></ul></dd></div></dl><div class="method-member-container mt-20"><strong>Returns:</strong><div class="param-desc"><p>A promise that will be resolved to <code>true</code> if all values pass the truth test and <code>false</code> if a least one of them doesn't pass it. That promise will be rejected if one of the truth test throws an exception.</p></div><dl class="param-type"><dt>Type:&nbsp;</dt><dd><span class="param-type">Promise.&lt;boolean></span></dd></dl></div><div class="method-member-container flex flex-col w-100 overflow-auto mt-20"><strong>Example</strong><div class="rel"><pre class="prettyprint"><code>import { everySeries, sleep } from 'modern-async'

const array = [1, 2, 3]

const result = await everySeries(array, async (v) => {
  // these calls will be performed sequentially
  await sleep(10) // waits 10ms
  return v > 0
})
console.log(result) // prints true
// total processing time should be ~ 30ms</code></pre></div></div><h3 class="name has-anchor" id="filter"><span class="type-signature">(async) </span>filter<span class="signature">(iterable, iteratee)</span><span class="type-signature"> &rarr; {Promise.&lt;Array.&lt;any>>}</span></h3><div class="description"><p>Returns an array of all the values in <code>iterable</code> which pass an asynchronous truth test.</p><p>The calls to <code>iteratee</code> will perform in parallel. The results will be in the same order than in <code>iterable</code>.</p><p>If any of the calls to <code>iteratee</code> throws an exception the returned promise will be rejected.</p></div><div class="method-member-container flex flex-col w-100 overflow-auto mt-20"><strong>Parameters:</strong><table class="params"><thead><tr><th>Name</th><th>Type</th><th class="last">Description</th></tr></thead><tbody><tr><td class="name"><code>iterable</code></td><td class="type"><span class="param-type">Iterable</span> |<wbr> <span class="param-type">AsyncIterable</span></td><td class="description last"><p>An iterable or async iterable object.</p></td></tr><tr><td class="name"><code>iteratee</code></td><td class="type"><span class="param-type">function</span></td><td class="description last"><p>A function that will be called with each member of <code>iterable</code>. It will receive three arguments:</p><ul><li><code>value</code>: The current value to process</li><li><code>index</code>: The index in the iterable. Will start from 0.</li><li><code>iterable</code>: The iterable on which the operation is being performed.</li></ul></td></tr></tbody></table></div><dl class="details"><div class="details-item-container"><dt class="tag-source bold">Source</dt><dd class="tag-source"><ul><li><a href="filter.mjs.html">filter.mjs</a>, <a href="filter.mjs.html#line32">line 32</a></li></ul></dd></div></dl><div class="method-member-container mt-20"><strong>Returns:</strong><div class="param-desc"><p>A promise that will be resolved with an array containing all the values that passed the truth test. This promise will be rejected if any of the <code>iteratee</code> calls throws an exception.</p></div><dl class="param-type"><dt>Type:&nbsp;</dt><dd><span class="param-type">Promise.&lt;Array.&lt;any>></span></dd></dl></div><div class="method-member-container flex flex-col w-100 overflow-auto mt-20"><strong>Example</strong><div class="rel"><pre class="prettyprint"><code>import { filter, sleep } from 'modern-async'

const array = [1, 2, 3]
const result = await filter(array, async (v) => {
  // these calls will be performed in parallel
  await sleep(10) // waits 10ms
  return v % 2 === 1
})
console.log(result) // prints [1, 3]
// total processing time should be ~ 10ms
})</code></pre></div></div><h3 class="name has-anchor" id="filterGenerator"><span class="type-signature">(async, generator) </span>filterGenerator<span class="signature">(iterable, iteratee, queueOrConcurrency<span class="signature-attributes">opt</span>, ordered<span class="signature-attributes">opt</span>)</span><span class="type-signature"> &rarr; {any}</span></h3><div class="description"><p>Produces a an async iterator that will return each value or <code>iterable</code> which pass an asynchronous truth test.</p><p>The iterator will perform the calls to <code>iteratee</code> in a queue to limit the concurrency of these calls. The iterator will consume values from <code>iterable</code> only if slots are available in the queue.</p><p>If the returned iterator is not fully consumed it will stop consuming new values from <code>iterable</code> and scheduling new calls to <code>iteratee</code> in the queue, but already scheduled tasks will still be executed.</p><p>If <code>iterable</code> or any of the calls to <code>iteratee</code> throws an exception all pending tasks will be cancelled and the returned async iterator will throw that exception.</p></div><div class="method-member-container flex flex-col w-100 overflow-auto mt-20"><strong>Parameters:</strong><table class="params"><thead><tr><th>Name</th><th>Type</th><th>Attributes</th><th>Default</th><th class="last">Description</th></tr></thead><tbody><tr><td class="name"><code>iterable</code></td><td class="type"><span class="param-type">Iterable</span> |<wbr> <span class="param-type">AsyncIterable</span></td><td class="attributes"></td><td class="default"></td><td class="description last"><p>An iterable or async iterable object.</p></td></tr><tr><td class="name"><code>iteratee</code></td><td class="type"><span class="param-type">function</span></td><td class="attributes"></td><td class="default"></td><td class="description last"><p>A function that will be called with each member of the iterable. It will receive three arguments:</p><ul><li><code>value</code>: The current value to process</li><li><code>index</code>: The index in the iterable. Will start from 0.</li><li><code>iterable</code>: The iterable on which the operation is being performed.</li></ul></td></tr><tr><td class="name"><code>queueOrConcurrency</code></td><td class="type"><span class="param-type"><a href="Queue.html">Queue</a></span> |<wbr> <span class="param-type">number</span></td><td class="attributes">&lt;optional><br></td><td class="default">1</td><td class="description last"><p>If a queue is specified it will be used to schedule the calls to <code>iteratee</code>. If a number is specified it will be used as the concurrency of a Queue that will be created implicitly for the same purpose.</p></td></tr><tr><td class="name"><code>ordered</code></td><td class="type"><span class="param-type">boolean</span></td><td class="attributes">&lt;optional><br></td><td class="default">true</td><td class="description last"><p>If true the results will be yielded in the same order as in the source iterable, regardless of which calls to iteratee returned first. If false the the results will be yielded as soon as a call to iteratee returned.</p></td></tr></tbody></table></div><dl class="details"><div class="details-item-container"><dt class="tag-source bold">Source</dt><dd class="tag-source"><ul><li><a href="filterGenerator.mjs.html">filterGenerator.mjs</a>, <a href="filterGenerator.mjs.html#line50">line 50</a></li></ul></dd></div></dl><div class="method-member-container mt-20"><strong>Yields:</strong><div class="param-desc"><p>Each element of <code>iterable</code> for which <code>iteratee</code> returned <code>true</code>.</p></div><dl class="param-type"><dt>Type:&nbsp;</dt><dd><span class="param-type">any</span></dd></dl></div><div class="method-member-container flex flex-col w-100 overflow-auto mt-20"><strong>Example</strong><div class="rel"><pre class="prettyprint"><code>import {filterGenerator, sleep} from 'modern-async'

const iterator = function * () {
  for (let i = 0; i &lt; 10000; i += 1) {
    yield i
  }
}
const filterIterator = filterGenerator(iterator(), async (v) => {
  await sleep(1000)
  return v % 3 === 0
})
for await (const el of filterIterator) {
  console.log(el)
}
// will print "0", "3", "6", etc... Only one number will be printed every 3 seconds.</code></pre></div></div><h3 class="name has-anchor" id="filterLimit"><span class="type-signature">(async) </span>filterLimit<span class="signature">(iterable, iteratee, queueOrConcurrency)</span><span class="type-signature"> &rarr; {Promise.&lt;Array.&lt;any>>}</span></h3><div class="description"><p>Returns an array of all the values in <code>iterable</code> which pass an asynchronous truth test.</p><p>The calls to <code>iteratee</code> will be performed in a queue to limit the concurrency of these calls. The results will be in the same order than in <code>iterable</code>.</p><p>If any of the calls to <code>iteratee</code> throws an exception the returned promise will be rejected and the remaining pending tasks will be cancelled.</p></div><div class="method-member-container flex flex-col w-100 overflow-auto mt-20"><strong>Parameters:</strong><table class="params"><thead><tr><th>Name</th><th>Type</th><th class="last">Description</th></tr></thead><tbody><tr><td class="name"><code>iterable</code></td><td class="type"><span class="param-type">Iterable</span> |<wbr> <span class="param-type">AsyncIterable</span></td><td class="description last"><p>An iterable or async iterable object.</p></td></tr><tr><td class="name"><code>iteratee</code></td><td class="type"><span class="param-type">function</span></td><td class="description last"><p>A function that will be called with each member of <code>iterable</code>. It will receive three arguments:</p><ul><li><code>value</code>: The current value to process</li><li><code>index</code>: The index in the iterable. Will start from 0.</li><li><code>iterable</code>: The iterable on which the operation is being performed.</li></ul></td></tr><tr><td class="name"><code>queueOrConcurrency</code></td><td class="type"><span class="param-type"><a href="Queue.html">Queue</a></span> |<wbr> <span class="param-type">number</span></td><td class="description last"><p>If a queue is specified it will be used to schedule the calls to <code>iteratee</code>. If a number is specified it will be used as the concurrency of a Queue that will be created implicitly for the same purpose.</p></td></tr></tbody></table></div><dl class="details"><div class="details-item-container"><dt class="tag-source bold">Source</dt><dd class="tag-source"><ul><li><a href="filterLimit.mjs.html">filterLimit.mjs</a>, <a href="filterLimit.mjs.html#line39">line 39</a></li></ul></dd></div></dl><div class="method-member-container mt-20"><strong>Returns:</strong><div class="param-desc"><p>A promise that will be resolved with an array containing all the values that passed the truth test. This promise will be rejected if any of the <code>iteratee</code> calls throws an exception.</p></div><dl class="param-type"><dt>Type:&nbsp;</dt><dd><span class="param-type">Promise.&lt;Array.&lt;any>></span></dd></dl></div><div class="method-member-container flex flex-col w-100 overflow-auto mt-20"><strong>Example</strong><div class="rel"><pre class="prettyprint"><code>import { filterLimit, sleep } from 'modern-async'

const array = [1, 2, 3]
const result = await filterLimit(array, async (v) => {
  // these calls will be performed in parallel with a maximum of 2
  // concurrent calls
  await sleep(10) // waits 10ms
  return v % 2 === 1
}, 2)
console.log(result) // prints [1, 3]
// total processing time should be ~ 20ms</code></pre></div></div><h3 class="name has-anchor" id="filterSeries"><span class="type-signature">(async) </span>filterSeries<span class="signature">(iterable, iteratee)</span><span class="type-signature"> &rarr; {Promise.&lt;Array.&lt;any>>}</span></h3><div class="description"><p>Returns an array of all the values in <code>iterable</code> which pass an asynchronous truth test.</p><p>The calls to <code>iteratee</code> will perform sequentially. The results will be in the same order than in <code>iterable</code>.</p><p>If any of the calls to <code>iteratee</code> throws an exception the returned promise will be rejected and the remaining pending tasks will be cancelled.</p></div><div class="method-member-container flex flex-col w-100 overflow-auto mt-20"><strong>Parameters:</strong><table class="params"><thead><tr><th>Name</th><th>Type</th><th class="last">Description</th></tr></thead><tbody><tr><td class="name"><code>iterable</code></td><td class="type"><span class="param-type">Iterable</span> |<wbr> <span class="param-type">AsyncIterable</span></td><td class="description last"><p>An iterable or async iterable object.</p></td></tr><tr><td class="name"><code>iteratee</code></td><td class="type"><span class="param-type">function</span></td><td class="description last"><p>A function that will be called with each member of the iterable. It will receive three arguments:</p><ul><li><code>value</code>: The current value to process</li><li><code>index</code>: The index in the iterable. Will start from 0.</li><li><code>iterable</code>: The iterable on which the operation is being performed.</li></ul></td></tr></tbody></table></div><dl class="details"><div class="details-item-container"><dt class="tag-source bold">Source</dt><dd class="tag-source"><ul><li><a href="filterSeries.mjs.html">filterSeries.mjs</a>, <a href="filterSeries.mjs.html#line33">line 33</a></li></ul></dd></div></dl><div class="method-member-container mt-20"><strong>Returns:</strong><div class="param-desc"><p>A promise that will be resolved with an array containing all the values that passed the truth test. This promise will be rejected if any of the <code>iteratee</code> calls throws an exception.</p></div><dl class="param-type"><dt>Type:&nbsp;</dt><dd><span class="param-type">Promise.&lt;Array.&lt;any>></span></dd></dl></div><div class="method-member-container flex flex-col w-100 overflow-auto mt-20"><strong>Example</strong><div class="rel"><pre class="prettyprint"><code>import { filterSeries, sleep } from 'modern-async'

const array = [1, 2, 3]
const result = await filterSeries(array, async (v) => {
  // these calls will be performed sequentially
  await sleep(10) // waits 10ms
  return v % 2 === 1
})
console.log(result) // prints [1, 3]
// total processing time should be ~ 30ms
})</code></pre></div></div><h3 class="name has-anchor" id="find"><span class="type-signature">(async) </span>find<span class="signature">(iterable, iteratee, ordered<span class="signature-attributes">opt</span>)</span><span class="type-signature"> &rarr; {Promise.&lt;(any|undefined)>}</span></h3><div class="description"><p>Returns the first element of an iterable that passes an asynchronous truth test.</p><p>The calls to <code>iteratee</code> will run in parallel.</p><p>In case of exception in one of the <code>iteratee</code> calls the promise returned by this function will be rejected with the exception. In the very specific case where a result is found and an already started task throws an exception that exception will be plainly ignored.</p></div><div class="method-member-container flex flex-col w-100 overflow-auto mt-20"><strong>Parameters:</strong><table class="params"><thead><tr><th>Name</th><th>Type</th><th>Attributes</th><th>Default</th><th class="last">Description</th></tr></thead><tbody><tr><td class="name"><code>iterable</code></td><td class="type"><span class="param-type">Iterable</span> |<wbr> <span class="param-type">AsyncIterable</span></td><td class="attributes"></td><td class="default"></td><td class="description last"><p>An iterable or async iterable object.</p></td></tr><tr><td class="name"><code>iteratee</code></td><td class="type"><span class="param-type">function</span></td><td class="attributes"></td><td class="default"></td><td class="description last"><p>A function that will be called with each member of the iterable. It will receive three arguments:</p><ul><li><code>value</code>: The current value to process</li><li><code>index</code>: The index in the iterable. Will start from 0.</li><li><code>iterable</code>: The iterable on which the operation is being performed.</li></ul></td></tr><tr><td class="name"><code>ordered</code></td><td class="type"><span class="param-type">boolean</span></td><td class="attributes">&lt;optional><br></td><td class="default">false</td><td class="description last"><p>If true this function will return on the first element in the iterable order for which <code>iteratee</code> returned true. If false it will be the first in time.</p></td></tr></tbody></table></div><dl class="details"><div class="details-item-container"><dt class="tag-source bold">Source</dt><dd class="tag-source"><ul><li><a href="find.mjs.html">find.mjs</a>, <a href="find.mjs.html#line34">line 34</a></li></ul></dd></div></dl><div class="method-member-container mt-20"><strong>Returns:</strong><div class="param-desc"><p>A promise that will be resolved with the first found value or rejected if one of the <code>iteratee</code> calls throws an exception before finding a value. If no value is found it will return <code>undefined</code>.</p></div><dl class="param-type"><dt>Type:&nbsp;</dt><dd><span class="param-type">Promise.&lt;(any|undefined)></span></dd></dl></div><div class="method-member-container flex flex-col w-100 overflow-auto mt-20"><strong>Example</strong><div class="rel"><pre class="prettyprint"><code>import { find, sleep } from 'modern-async'

const array = [1, 2, 3]
const result = await find(array, async (v) => {
  // these calls will be performed in parallel
  await sleep(Math.random() * 10) // waits a random amount of time between 0ms and 10ms
  return v % 2 === 1
})
console.log(result) // prints 1</code></pre></div></div><h3 class="name has-anchor" id="findIndex"><span class="type-signature">(async) </span>findIndex<span class="signature">(iterable, iteratee, ordered<span class="signature-attributes">opt</span>)</span><span class="type-signature"> &rarr; {Promise.&lt;number>}</span></h3><div class="description"><p>Returns the index of the first element of an iterable that passes an asynchronous truth test.</p><p>The calls to <code>iteratee</code> will run in parallel.</p><p>In case of exception in one of the <code>iteratee</code> calls the promise returned by this function will be rejected with the exception. In the very specific case where a result is found and an already started task throws an exception that exception will be plainly ignored.</p></div><div class="method-member-container flex flex-col w-100 overflow-auto mt-20"><strong>Parameters:</strong><table class="params"><thead><tr><th>Name</th><th>Type</th><th>Attributes</th><th>Default</th><th class="last">Description</th></tr></thead><tbody><tr><td class="name"><code>iterable</code></td><td class="type"><span class="param-type">Iterable</span> |<wbr> <span class="param-type">AsyncIterable</span></td><td class="attributes"></td><td class="default"></td><td class="description last"><p>An iterable or async iterable object.</p></td></tr><tr><td class="name"><code>iteratee</code></td><td class="type"><span class="param-type">function</span></td><td class="attributes"></td><td class="default"></td><td class="description last"><p>A function that will be called with each member of the iterable. It will receive three arguments:</p><ul><li><code>value</code>: The current value to process</li><li><code>index</code>: The index in the iterable. Will start from 0.</li><li><code>iterable</code>: The iterable on which the operation is being performed.</li></ul></td></tr><tr><td class="name"><code>ordered</code></td><td class="type"><span class="param-type">boolean</span></td><td class="attributes">&lt;optional><br></td><td class="default">false</td><td class="description last"><p>If true this function will return on the first element in the iterable order for which <code>iteratee</code> returned true. If false it will be the first in time.</p></td></tr></tbody></table></div><dl class="details"><div class="details-item-container"><dt class="tag-source bold">Source</dt><dd class="tag-source"><ul><li><a href="findIndex.mjs.html">findIndex.mjs</a>, <a href="findIndex.mjs.html#line34">line 34</a></li></ul></dd></div></dl><div class="method-member-container mt-20"><strong>Returns:</strong><div class="param-desc"><p>A promise that will be resolved with the index of the first found value or rejected if one of the <code>iteratee</code> calls throws an exception before finding a value. If no value is found it will return <code>-1</code>.</p></div><dl class="param-type"><dt>Type:&nbsp;</dt><dd><span class="param-type">Promise.&lt;number></span></dd></dl></div><div class="method-member-container flex flex-col w-100 overflow-auto mt-20"><strong>Example</strong><div class="rel"><pre class="prettyprint"><code>import { findIndex, sleep } from 'modern-async'

const array = [1, 2, 3]
const result = await findIndex(array, async (v) => {
  // these calls will be performed in parallel
  await sleep(Math.random() * 10) // waits a random amount of time between 0ms and 10ms
  return v % 2 === 1
})
console.log(result) // prints 0</code></pre></div></div><h3 class="name has-anchor" id="findIndexLimit"><span class="type-signature">(async) </span>findIndexLimit<span class="signature">(iterable, iteratee, queueOrConcurrency, ordered<span class="signature-attributes">opt</span>)</span><span class="type-signature"> &rarr; {Promise.&lt;number>}</span></h3><div class="description"><p>Returns the index of the first element of an iterable that passes an asynchronous truth test.</p><p>The calls to <code>iteratee</code> will be performed in a queue to limit the concurrency of these calls.</p><p>Whenever a result is found, all the remaining tasks will be cancelled as long as they didn't started already. In case of exception in one of the iteratee calls the promise returned by this function will be rejected with the exception and the remaining pending tasks will also be cancelled. In the very specific case where a result is found and an already started task throws an exception that exception will be plainly ignored.</p></div><div class="method-member-container flex flex-col w-100 overflow-auto mt-20"><strong>Parameters:</strong><table class="params"><thead><tr><th>Name</th><th>Type</th><th>Attributes</th><th>Default</th><th class="last">Description</th></tr></thead><tbody><tr><td class="name"><code>iterable</code></td><td class="type"><span class="param-type">Iterable</span> |<wbr> <span class="param-type">AsyncIterable</span></td><td class="attributes"></td><td class="default"></td><td class="description last"><p>An iterable or async iterable object.</p></td></tr><tr><td class="name"><code>iteratee</code></td><td class="type"><span class="param-type">function</span></td><td class="attributes"></td><td class="default"></td><td class="description last"><p>A function that will be called with each member of the iterable. It will receive three arguments:</p><ul><li><code>value</code>: The current value to process</li><li><code>index</code>: The index in the iterable. Will start from 0.</li><li><code>iterable</code>: The iterable on which the operation is being performed.</li></ul></td></tr><tr><td class="name"><code>queueOrConcurrency</code></td><td class="type"><span class="param-type"><a href="Queue.html">Queue</a></span> |<wbr> <span class="param-type">number</span></td><td class="attributes"></td><td class="default"></td><td class="description last"><p>If a queue is specified it will be used to schedule the calls to <code>iteratee</code>. If a number is specified it will be used as the concurrency of a Queue that will be created implicitly for the same purpose.</p></td></tr><tr><td class="name"><code>ordered</code></td><td class="type"><span class="param-type">boolean</span></td><td class="attributes">&lt;optional><br></td><td class="default">false</td><td class="description last"><p>If true this function will return on the first element in the iterable order for which <code>iteratee</code> returned true. If false it will be the first in time.</p></td></tr></tbody></table></div><dl class="details"><div class="details-item-container"><dt class="tag-source bold">Source</dt><dd class="tag-source"><ul><li><a href="findIndexLimit.mjs.html">findIndexLimit.mjs</a>, <a href="findIndexLimit.mjs.html#line41">line 41</a></li></ul></dd></div></dl><div class="method-member-container mt-20"><strong>Returns:</strong><div class="param-desc"><p>A promise that will be resolved with the index of the first found value or rejected if one of the <code>iteratee</code> calls throws an exception before finding a value. If no value is found it will return <code>-1</code>.</p></div><dl class="param-type"><dt>Type:&nbsp;</dt><dd><span class="param-type">Promise.&lt;number></span></dd></dl></div><div class="method-member-container flex flex-col w-100 overflow-auto mt-20"><strong>Example</strong><div class="rel"><pre class="prettyprint"><code>import { findIndexLimit, sleep } from 'modern-async'

const array = [1, 2, 3, 4, 5]
const result = await findIndexLimit(array, async (v) => {
  // these calls will be performed in parallel with a maximum of 3
  // concurrent calls
  await sleep(Math.random() * 10) // waits a random amount of time between 0ms and 10ms
  return v % 2 === 1
}, 3)
console.log(result) // prints 0</code></pre></div></div><h3 class="name has-anchor" id="findIndexSeries"><span class="type-signature">(async) </span>findIndexSeries<span class="signature">(iterable, iteratee)</span><span class="type-signature"> &rarr; {Promise.&lt;number>}</span></h3><div class="description"><p>Returns the index of the first element of an iterable that passes an asynchronous truth test.</p><p>The calls to <code>iteratee</code> will run sequentially.</p><p>In case of exception in one of the <code>iteratee</code> calls the promise returned by this function will be rejected with the exception and the remaining pending tasks will be cancelled.</p></div><div class="method-member-container flex flex-col w-100 overflow-auto mt-20"><strong>Parameters:</strong><table class="params"><thead><tr><th>Name</th><th>Type</th><th class="last">Description</th></tr></thead><tbody><tr><td class="name"><code>iterable</code></td><td class="type"><span class="param-type">Iterable</span> |<wbr> <span class="param-type">AsyncIterable</span></td><td class="description last"><p>An iterable or async iterable object.</p></td></tr><tr><td class="name"><code>iteratee</code></td><td class="type"><span class="param-type">function</span></td><td class="description last"><p>A function that will be called with each member of the iterable. It will receive three arguments:</p><ul><li><code>value</code>: The current value to process</li><li><code>index</code>: The index in the iterable. Will start from 0.</li><li><code>iterable</code>: The iterable on which the operation is being performed.</li></ul></td></tr></tbody></table></div><dl class="details"><div class="details-item-container"><dt class="tag-source bold">Source</dt><dd class="tag-source"><ul><li><a href="findIndexSeries.mjs.html">findIndexSeries.mjs</a>, <a href="findIndexSeries.mjs.html#line31">line 31</a></li></ul></dd></div></dl><div class="method-member-container mt-20"><strong>Returns:</strong><div class="param-desc"><p>A promise that will be resolved with the index of the first found value or rejected if one of the <code>iteratee</code> calls throws an exception before finding a value. If no value is found it will return <code>-1</code>.</p></div><dl class="param-type"><dt>Type:&nbsp;</dt><dd><span class="param-type">Promise.&lt;number></span></dd></dl></div><div class="method-member-container flex flex-col w-100 overflow-auto mt-20"><strong>Example</strong><div class="rel"><pre class="prettyprint"><code>import { findIndexSeries, sleep } from 'modern-async'

const array = [1, 2, 3]
const result = await findIndexSeries(array, async (v) => {
  // these calls will be performed sequentially
  await sleep(Math.random() * 10) // waits a random amount of time between 0ms and 10ms
  return v % 2 === 1
})
console.log(result) // prints 0</code></pre></div></div><h3 class="name has-anchor" id="findLimit"><span class="type-signature">(async) </span>findLimit<span class="signature">(iterable, iteratee, queueOrConcurrency, ordered<span class="signature-attributes">opt</span>)</span><span class="type-signature"> &rarr; {Promise.&lt;(any|undefined)>}</span></h3><div class="description"><p>Returns the first element of an iterable that passes an asynchronous truth test.</p><p>The calls to <code>iteratee</code> will be performed in a queue to limit the concurrency of these calls.</p><p>Whenever a result is found, all the remaining tasks will be cancelled as long as they didn't started already. In case of exception in one of the <code>iteratee</code> calls the promise returned by this function will be rejected with the exception and the remaining pending tasks will also be cancelled. In the very specific case where a result is found and an already started task throws an exception that exception will be plainly ignored.</p></div><div class="method-member-container flex flex-col w-100 overflow-auto mt-20"><strong>Parameters:</strong><table class="params"><thead><tr><th>Name</th><th>Type</th><th>Attributes</th><th>Default</th><th class="last">Description</th></tr></thead><tbody><tr><td class="name"><code>iterable</code></td><td class="type"><span class="param-type">Iterable</span> |<wbr> <span class="param-type">AsyncIterable</span></td><td class="attributes"></td><td class="default"></td><td class="description last"><p>An iterable or async iterable object.</p></td></tr><tr><td class="name"><code>iteratee</code></td><td class="type"><span class="param-type">function</span></td><td class="attributes"></td><td class="default"></td><td class="description last"><p>A function that will be called with each member of the iterable. It will receive three arguments:</p><ul><li><code>value</code>: The current value to process</li><li><code>index</code>: The index in the iterable. Will start from 0.</li><li><code>iterable</code>: The iterable on which the operation is being performed.</li></ul></td></tr><tr><td class="name"><code>queueOrConcurrency</code></td><td class="type"><span class="param-type"><a href="Queue.html">Queue</a></span> |<wbr> <span class="param-type">number</span></td><td class="attributes"></td><td class="default"></td><td class="description last"><p>If a queue is specified it will be used to schedule the calls to <code>iteratee</code>. If a number is specified it will be used as the concurrency of a Queue that will be created implicitly for the same purpose.</p></td></tr><tr><td class="name"><code>ordered</code></td><td class="type"><span class="param-type">boolean</span></td><td class="attributes">&lt;optional><br></td><td class="default">false</td><td class="description last"><p>If true this function will return on the first element in the iterable order for which <code>iteratee</code> returned true. If false it will be the first in time.</p></td></tr></tbody></table></div><dl class="details"><div class="details-item-container"><dt class="tag-source bold">Source</dt><dd class="tag-source"><ul><li><a href="findLimit.mjs.html">findLimit.mjs</a>, <a href="findLimit.mjs.html#line41">line 41</a></li></ul></dd></div></dl><div class="method-member-container mt-20"><strong>Returns:</strong><div class="param-desc"><p>A promise that will be resolved with the first found value or rejected if one of the <code>iteratee</code> calls throws an exception before finding a value. If no value is found it will return <code>undefined</code>.</p></div><dl class="param-type"><dt>Type:&nbsp;</dt><dd><span class="param-type">Promise.&lt;(any|undefined)></span></dd></dl></div><div class="method-member-container flex flex-col w-100 overflow-auto mt-20"><strong>Example</strong><div class="rel"><pre class="prettyprint"><code>import { findLimit, sleep } from 'modern-async'

const array = [1, 2, 3, 4, 5]
const result = await findLimit(array, async (v) => {
  // these calls will be performed in parallel with a maximum of 3
  // concurrent calls
  await sleep(Math.random() * 10) // waits a random amount of time between 0ms and 10ms
  return v % 2 === 1
}, 3)
console.log(result) // prints 1</code></pre></div></div><h3 class="name has-anchor" id="findSeries"><span class="type-signature">(async) </span>findSeries<span class="signature">(iterable, iteratee)</span><span class="type-signature"> &rarr; {Promise.&lt;(any|undefined)>}</span></h3><div class="description"><p>Returns the first element of an iterable that passes an asynchronous truth test.</p><p>The calls to <code>iteratee</code> will run sequentially.</p><p>In case of exception in one of the <code>iteratee</code> calls the promise returned by this function will be rejected with the exception and the remaining pending tasks will be cancelled.</p></div><div class="method-member-container flex flex-col w-100 overflow-auto mt-20"><strong>Parameters:</strong><table class="params"><thead><tr><th>Name</th><th>Type</th><th class="last">Description</th></tr></thead><tbody><tr><td class="name"><code>iterable</code></td><td class="type"><span class="param-type">Iterable</span> |<wbr> <span class="param-type">AsyncIterable</span></td><td class="description last"><p>An iterable or async iterable object.</p></td></tr><tr><td class="name"><code>iteratee</code></td><td class="type"><span class="param-type">function</span></td><td class="description last"><p>A function that will be called with each member of the iterable. It will receive three arguments:</p><ul><li><code>value</code>: The current value to process</li><li><code>index</code>: The index in the iterable. Will start from 0.</li><li><code>iterable</code>: The iterable on which the operation is being performed.</li></ul></td></tr></tbody></table></div><dl class="details"><div class="details-item-container"><dt class="tag-source bold">Source</dt><dd class="tag-source"><ul><li><a href="findSeries.mjs.html">findSeries.mjs</a>, <a href="findSeries.mjs.html#line31">line 31</a></li></ul></dd></div></dl><div class="method-member-container mt-20"><strong>Returns:</strong><div class="param-desc"><p>A promise that will be resolved with the first found value or rejected if one of the <code>iteratee</code> calls throws an exception before finding a value. If no value is found it will return <code>undefined</code>.</p></div><dl class="param-type"><dt>Type:&nbsp;</dt><dd><span class="param-type">Promise.&lt;(any|undefined)></span></dd></dl></div><div class="method-member-container flex flex-col w-100 overflow-auto mt-20"><strong>Example</strong><div class="rel"><pre class="prettyprint"><code>import { findSeries, sleep } from 'modern-async'

const array = [1, 2, 3]
const result = await findSeries(array, async (v) => {
  // these calls will be performed sequentially
  await sleep(Math.random() * 10) // waits a random amount of time between 0ms and 10ms
  return v % 2 === 1
})
console.log(result) // prints 1</code></pre></div></div><h3 class="name has-anchor" id="forEach"><span class="type-signature">(async) </span>forEach<span class="signature">(iterable, iteratee)</span><span class="type-signature"> &rarr; {Promise}</span></h3><div class="description"><p>Calls a function on each element of iterable.</p><p>Multiple calls to <code>iteratee</code> will be performed in parallel.</p><p>If any of the calls to iteratee throws an exception the returned promise will be rejected.</p></div><div class="method-member-container flex flex-col w-100 overflow-auto mt-20"><strong>Parameters:</strong><table class="params"><thead><tr><th>Name</th><th>Type</th><th class="last">Description</th></tr></thead><tbody><tr><td class="name"><code>iterable</code></td><td class="type"><span class="param-type">Iterable</span> |<wbr> <span class="param-type">AsyncIterable</span></td><td class="description last"><p>An iterable or async iterable object.</p></td></tr><tr><td class="name"><code>iteratee</code></td><td class="type"><span class="param-type">function</span></td><td class="description last"><p>A function that will be called with each member of the iterable. It will receive three arguments:</p><ul><li><code>value</code>: The current value to process</li><li><code>index</code>: The index in the iterable. Will start from 0.</li><li><code>iterable</code>: The iterable on which the operation is being performed.</li></ul></td></tr></tbody></table></div><dl class="details"><div class="details-item-container"><dt class="tag-source bold">Source</dt><dd class="tag-source"><ul><li><a href="forEach.mjs.html">forEach.mjs</a>, <a href="forEach.mjs.html#line31">line 31</a></li></ul></dd></div></dl><div class="method-member-container mt-20"><strong>Returns:</strong><div class="param-desc"><p>A promise that will be resolved when all the calls to <code>iteratee</code> have been done. This promise will be rejected if any call to <code>iteratee</code> throws an exception.</p></div><dl class="param-type"><dt>Type:&nbsp;</dt><dd><span class="param-type">Promise</span></dd></dl></div><div class="method-member-container flex flex-col w-100 overflow-auto mt-20"><strong>Example</strong><div class="rel"><pre class="prettyprint"><code>import { forEach, sleep } from 'modern-async'

const array = [1, 2, 3]
await forEach(array, async (v) => {
  // these calls will be performed in parallel
  await sleep(Math.random() * 10) // waits a random amount of time between 0ms and 10ms
  console.log(v)
})
// prints 1, 2 and 3 in a random order
})</code></pre></div></div><h3 class="name has-anchor" id="forEachLimit"><span class="type-signature">(async) </span>forEachLimit<span class="signature">(iterable, iteratee, queueOrConcurrency)</span><span class="type-signature"> &rarr; {Promise}</span></h3><div class="description"><p>Calls a function on each element of iterable.</p><p>The calls to <code>iteratee</code> will be performed in a queue to limit the concurrency of these calls.</p><p>If any of the calls to iteratee throws an exception the returned promise will be rejected and the remaining pending tasks will be cancelled.</p></div><div class="method-member-container flex flex-col w-100 overflow-auto mt-20"><strong>Parameters:</strong><table class="params"><thead><tr><th>Name</th><th>Type</th><th class="last">Description</th></tr></thead><tbody><tr><td class="name"><code>iterable</code></td><td class="type"><span class="param-type">Iterable</span> |<wbr> <span class="param-type">AsyncIterable</span></td><td class="description last"><p>An iterable or async iterable object.</p></td></tr><tr><td class="name"><code>iteratee</code></td><td class="type"><span class="param-type">function</span></td><td class="description last"><p>A function that will be called with each member of the iterable. It will receive three arguments:</p><ul><li><code>value</code>: The current value to process</li><li><code>index</code>: The index in the iterable. Will start from 0.</li><li><code>iterable</code>: The iterable on which the operation is being performed.</li></ul></td></tr><tr><td class="name"><code>queueOrConcurrency</code></td><td class="type"><span class="param-type"><a href="Queue.html">Queue</a></span> |<wbr> <span class="param-type">number</span></td><td class="description last"><p>If a queue is specified it will be used to schedule the calls to <code>iteratee</code>. If a number is specified it will be used as the concurrency of a Queue that will be created implicitly for the same purpose.</p></td></tr></tbody></table></div><dl class="details"><div class="details-item-container"><dt class="tag-source bold">Source</dt><dd class="tag-source"><ul><li><a href="forEachLimit.mjs.html">forEachLimit.mjs</a>, <a href="forEachLimit.mjs.html#line37">line 37</a></li></ul></dd></div></dl><div class="method-member-container mt-20"><strong>Returns:</strong><div class="param-desc"><p>A promise that will be resolved when all the calls to <code>iteratee</code> have been done. This promise will be rejected if any call to <code>iteratee</code> throws an exception.</p></div><dl class="param-type"><dt>Type:&nbsp;</dt><dd><span class="param-type">Promise</span></dd></dl></div><div class="method-member-container flex flex-col w-100 overflow-auto mt-20"><strong>Example</strong><div class="rel"><pre class="prettyprint"><code>import { forEachLimit, sleep } from 'modern-async'

const array = [1, 2, 3]
await forEachLimit(array, async (v) => {
  // these calls will be performed in parallel with a maximum of 2
  // concurrent calls
  await sleep(Math.random() * 10) // waits a random amount of time between 0ms and 10ms
  console.log(v)
}, 2)
// prints 1, 2 and 3 in a random order (it will always print 1 or 2 before printing 3 due to
// the concurrency limit and the internal scheduling order)</code></pre></div></div><h3 class="name has-anchor" id="forEachSeries"><span class="type-signature">(async) </span>forEachSeries<span class="signature">(iterable, iteratee)</span><span class="type-signature"> &rarr; {Promise}</span></h3><div class="description"><p>Calls a function on each element of iterable.</p><p>Multiple calls to <code>iteratee</code> will be performed sequentially.</p><p>If any of the calls to iteratee throws an exception the returned promise will be rejected and the remaining pending tasks will be cancelled.</p></div><div class="method-member-container flex flex-col w-100 overflow-auto mt-20"><strong>Parameters:</strong><table class="params"><thead><tr><th>Name</th><th>Type</th><th class="last">Description</th></tr></thead><tbody><tr><td class="name"><code>iterable</code></td><td class="type"><span class="param-type">Iterable</span> |<wbr> <span class="param-type">AsyncIterable</span></td><td class="description last"><p>An iterable or async iterable object.</p></td></tr><tr><td class="name"><code>iteratee</code></td><td class="type"><span class="param-type">function</span></td><td class="description last"><p>A function that will be called with each member of the iterable. It will receive three arguments:</p><ul><li><code>value</code>: The current value to process</li><li><code>index</code>: The index in the iterable. Will start from 0.</li><li><code>iterable</code>: The iterable on which the operation is being performed.</li></ul></td></tr></tbody></table></div><dl class="details"><div class="details-item-container"><dt class="tag-source bold">Source</dt><dd class="tag-source"><ul><li><a href="forEachSeries.mjs.html">forEachSeries.mjs</a>, <a href="forEachSeries.mjs.html#line31">line 31</a></li></ul></dd></div></dl><div class="method-member-container mt-20"><strong>Returns:</strong><div class="param-desc"><p>A promise that will be resolved when all the calls to <code>iteratee</code> have been done. This promise will be rejected if any call to <code>iteratee</code> throws an exception.</p></div><dl class="param-type"><dt>Type:&nbsp;</dt><dd><span class="param-type">Promise</span></dd></dl></div><div class="method-member-container flex flex-col w-100 overflow-auto mt-20"><strong>Example</strong><div class="rel"><pre class="prettyprint"><code>import { forEachSeries, sleep } from 'modern-async'

const array = [1, 2, 3]
await forEachSeries(array, async (v) => {
  // these calls will be performed sequentially
  await sleep(Math.random() * 10) // waits a random amount of time between 0ms and 10ms
  console.log(v)
})
// prints 1, 2 and 3 in that exact order</code></pre></div></div><h3 class="name has-anchor" id="map"><span class="type-signature">(async) </span>map<span class="signature">(iterable, iteratee)</span><span class="type-signature"> &rarr; {Promise.&lt;Array.&lt;any>>}</span></h3><div class="description"><p>Produces a new collection of values by mapping each value in <code>iterable</code> through the <code>iteratee</code> function.</p><p>Multiple calls to <code>iteratee</code> will be performed in parallel.</p><p>If any of the calls to iteratee throws an exception the returned promise will be rejected.</p></div><div class="method-member-container flex flex-col w-100 overflow-auto mt-20"><strong>Parameters:</strong><table class="params"><thead><tr><th>Name</th><th>Type</th><th class="last">Description</th></tr></thead><tbody><tr><td class="name"><code>iterable</code></td><td class="type"><span class="param-type">Iterable</span> |<wbr> <span class="param-type">AsyncIterable</span></td><td class="description last"><p>An iterable or async iterable object.</p></td></tr><tr><td class="name"><code>iteratee</code></td><td class="type"><span class="param-type">function</span></td><td class="description last"><p>A function that will be called with each member of the iterable. It will receive three arguments:</p><ul><li><code>value</code>: The current value to process</li><li><code>index</code>: The index in the iterable. Will start from 0.</li><li><code>iterable</code>: The iterable on which the operation is being performed.</li></ul></td></tr></tbody></table></div><dl class="details"><div class="details-item-container"><dt class="tag-source bold">Source</dt><dd class="tag-source"><ul><li><a href="map.mjs.html">map.mjs</a>, <a href="map.mjs.html#line31">line 31</a></li></ul></dd></div></dl><div class="method-member-container mt-20"><strong>Returns:</strong><div class="param-desc"><p>A promise that will be resolved with an array containing all the mapped value, or will be rejected if any of the calls to <code>iteratee</code> throws an exception.</p></div><dl class="param-type"><dt>Type:&nbsp;</dt><dd><span class="param-type">Promise.&lt;Array.&lt;any>></span></dd></dl></div><div class="method-member-container flex flex-col w-100 overflow-auto mt-20"><strong>Example</strong><div class="rel"><pre class="prettyprint"><code>import { map, sleep } from 'modern-async'

const array = [1, 2, 3]
const result = await map(array, async (v) => {
  // these calls will be performed in parallel
  await sleep(10) // waits 10ms
  return v * 2
})
console.log(result) // prints [2, 4, 6]
// total processing time should be ~ 10ms</code></pre></div></div><h3 class="name has-anchor" id="mapGenerator"><span class="type-signature">(async, generator) </span>mapGenerator<span class="signature">(iterable, iteratee, queueOrConcurrency<span class="signature-attributes">opt</span>, ordered<span class="signature-attributes">opt</span>)</span><span class="type-signature"> &rarr; {any}</span></h3><div class="description"><p>Produces a an async iterator that will return each value or <code>iterable</code> after having processed them through the <code>iteratee</code> function.</p><p>The iterator will perform the calls to <code>iteratee</code> in a queue to limit the concurrency of these calls. The iterator will consume values from <code>iterable</code> only if slots are available in the queue.</p><p>If the returned iterator is not fully consumed it will stop consuming new values from <code>iterable</code> and scheduling new calls to <code>iteratee</code> in the queue, but already scheduled tasks will still be executed.</p><p>If <code>iterable</code> or any of the calls to <code>iteratee</code> throws an exception all pending tasks will be cancelled and the returned async iterator will throw that exception.</p></div><div class="method-member-container flex flex-col w-100 overflow-auto mt-20"><strong>Parameters:</strong><table class="params"><thead><tr><th>Name</th><th>Type</th><th>Attributes</th><th>Default</th><th class="last">Description</th></tr></thead><tbody><tr><td class="name"><code>iterable</code></td><td class="type"><span class="param-type">Iterable</span> |<wbr> <span class="param-type">AsyncIterable</span></td><td class="attributes"></td><td class="default"></td><td class="description last"><p>An iterable or async iterable object.</p></td></tr><tr><td class="name"><code>iteratee</code></td><td class="type"><span class="param-type">function</span></td><td class="attributes"></td><td class="default"></td><td class="description last"><p>A function that will be called with each member of the iterable. It will receive three arguments:</p><ul><li><code>value</code>: The current value to process</li><li><code>index</code>: The index in the iterable. Will start from 0.</li><li><code>iterable</code>: The iterable on which the operation is being performed.</li></ul></td></tr><tr><td class="name"><code>queueOrConcurrency</code></td><td class="type"><span class="param-type"><a href="Queue.html">Queue</a></span> |<wbr> <span class="param-type">number</span></td><td class="attributes">&lt;optional><br></td><td class="default">1</td><td class="description last"><p>If a queue is specified it will be used to schedule the calls to <code>iteratee</code>. If a number is specified it will be used as the concurrency of a Queue that will be created implicitly for the same purpose.</p></td></tr><tr><td class="name"><code>ordered</code></td><td class="type"><span class="param-type">boolean</span></td><td class="attributes">&lt;optional><br></td><td class="default">true</td><td class="description last"><p>If true the results will be yielded in the same order as in the source iterable, regardless of which calls to iteratee returned first. If false the the results will be yielded as soon as a call to iteratee returned.</p></td></tr></tbody></table></div><dl class="details"><div class="details-item-container"><dt class="tag-source bold">Source</dt><dd class="tag-source"><ul><li><a href="mapGenerator.mjs.html">mapGenerator.mjs</a>, <a href="mapGenerator.mjs.html#line53">line 53</a></li></ul></dd></div></dl><div class="method-member-container mt-20"><strong>Yields:</strong><div class="param-desc"><p>Each element of <code>iterable</code> after processing it through <code>iteratee</code>.</p></div><dl class="param-type"><dt>Type:&nbsp;</dt><dd><span class="param-type">any</span></dd></dl></div><div class="method-member-container flex flex-col w-100 overflow-auto mt-20"><strong>Example</strong><div class="rel"><pre class="prettyprint"><code>import {mapGenerator, sleep} from 'modern-async'

const iterator = function * () {
  for (let i = 0; i &lt; 10000; i += 1) {
    yield i
  }
}
const mapIterator = mapGenerator(iterator(), async (v) => {
  await sleep(1000)
  return v * 2
})
for await (const el of mapIterator) {
  console.log(el)
}
// Will print "0", "2", "4", etc... Only one number will be printed per second.
// Numbers from `iterator` will be consumed progressively</code></pre></div></div><h3 class="name has-anchor" id="mapLimit"><span class="type-signature">(async) </span>mapLimit<span class="signature">(iterable, iteratee, queueOrConcurrency)</span><span class="type-signature"> &rarr; {Promise.&lt;Array.&lt;any>>}</span></h3><div class="description"><p>Produces a new collection of values by mapping each value in <code>iterable</code> through the <code>iteratee</code> function.</p><p>The calls to <code>iteratee</code> will be performed in a queue to limit the concurrency of these calls.</p><p>If any of the calls to iteratee throws an exception the returned promise will be rejected and the remaining pending tasks will be cancelled.</p></div><div class="method-member-container flex flex-col w-100 overflow-auto mt-20"><strong>Parameters:</strong><table class="params"><thead><tr><th>Name</th><th>Type</th><th class="last">Description</th></tr></thead><tbody><tr><td class="name"><code>iterable</code></td><td class="type"><span class="param-type">Iterable</span> |<wbr> <span class="param-type">AsyncIterable</span></td><td class="description last"><p>An iterable or async iterable object.</p></td></tr><tr><td class="name"><code>iteratee</code></td><td class="type"><span class="param-type">function</span></td><td class="description last"><p>A function that will be called with each member of the iterable. It will receive three arguments:</p><ul><li><code>value</code>: The current value to process</li><li><code>index</code>: The index in the iterable. Will start from 0.</li><li><code>iterable</code>: The iterable on which the operation is being performed.</li></ul></td></tr><tr><td class="name"><code>queueOrConcurrency</code></td><td class="type"><span class="param-type"><a href="Queue.html">Queue</a></span> |<wbr> <span class="param-type">number</span></td><td class="description last"><p>If a queue is specified it will be used to schedule the calls to <code>iteratee</code>. If a number is specified it will be used as the concurrency of a Queue that will be created implicitly for the same purpose.</p></td></tr></tbody></table></div><dl class="details"><div class="details-item-container"><dt class="tag-source bold">Source</dt><dd class="tag-source"><ul><li><a href="mapLimit.mjs.html">mapLimit.mjs</a>, <a href="mapLimit.mjs.html#line38">line 38</a></li></ul></dd></div></dl><div class="method-member-container mt-20"><strong>Returns:</strong><div class="param-desc"><p>A promise that will be resolved with an array containing all the mapped value, or will be rejected if any of the calls to <code>iteratee</code> throws an exception.</p></div><dl class="param-type"><dt>Type:&nbsp;</dt><dd><span class="param-type">Promise.&lt;Array.&lt;any>></span></dd></dl></div><div class="method-member-container flex flex-col w-100 overflow-auto mt-20"><strong>Example</strong><div class="rel"><pre class="prettyprint"><code>import { mapLimit, sleep } from 'modern-async'

const array = [1, 2, 3]
const result = await mapLimit(array, async (v) => {
  // these calls will be performed in parallel with a maximum of 2
  // concurrent calls
  await sleep(10) // waits 10ms
  return v * 2
}, 2)
console.log(result) // prints [2, 4, 6]
// total processing time should be ~ 20ms</code></pre></div></div><h3 class="name has-anchor" id="mapSeries"><span class="type-signature">(async) </span>mapSeries<span class="signature">(iterable, iteratee)</span><span class="type-signature"> &rarr; {Promise.&lt;Array.&lt;any>>}</span></h3><div class="description"><p>Produces a new collection of values by mapping each value in <code>iterable</code> through the <code>iteratee</code> function.</p><p>Multiple calls to <code>iteratee</code> will be performed sequentially.</p><p>If any of the calls to iteratee throws an exception the returned promise will be rejected and the remaining pending tasks will be cancelled.</p></div><div class="method-member-container flex flex-col w-100 overflow-auto mt-20"><strong>Parameters:</strong><table class="params"><thead><tr><th>Name</th><th>Type</th><th class="last">Description</th></tr></thead><tbody><tr><td class="name"><code>iterable</code></td><td class="type"><span class="param-type">Iterable</span> |<wbr> <span class="param-type">AsyncIterable</span></td><td class="description last"><p>An iterable or async iterable object.</p></td></tr><tr><td class="name"><code>iteratee</code></td><td class="type"><span class="param-type">function</span></td><td class="description last"><p>A function that will be called with each member of the iterable. It will receive three arguments:</p><ul><li><code>value</code>: The current value to process</li><li><code>index</code>: The index in the iterable. Will start from 0.</li><li><code>iterable</code>: The iterable on which the operation is being performed.</li></ul></td></tr></tbody></table></div><dl class="details"><div class="details-item-container"><dt class="tag-source bold">Source</dt><dd class="tag-source"><ul><li><a href="mapSeries.mjs.html">mapSeries.mjs</a>, <a href="mapSeries.mjs.html#line32">line 32</a></li></ul></dd></div></dl><div class="method-member-container mt-20"><strong>Returns:</strong><div class="param-desc"><p>A promise that will be resolved with an array containing all the mapped value, or will be rejected if any of the calls to <code>iteratee</code> throws an exception.</p></div><dl class="param-type"><dt>Type:&nbsp;</dt><dd><span class="param-type">Promise.&lt;Array.&lt;any>></span></dd></dl></div><div class="method-member-container flex flex-col w-100 overflow-auto mt-20"><strong>Example</strong><div class="rel"><pre class="prettyprint"><code>import { mapSeries, sleep } from 'modern-async'

const array = [1, 2, 3]
const result = await mapSeries(array, async (v) => {
  // these calls will be performed sequentially
  await sleep(10) // waits 10ms
  return v * 2
}, 2)
console.log(result) // prints [2, 4, 6]
// total processing time should be ~ 30ms</code></pre></div></div><h3 class="name has-anchor" id="queueMicrotask"><span class="type-signature"></span>queueMicrotask<span class="signature">(fct)</span></h3><div class="description"><p>An alternative to standard <code>queueMicrotask()</code> function.</p><p>This is just of mirror of core-js' implementation for compatibility.</p></div><div class="method-member-container flex flex-col w-100 overflow-auto mt-20"><strong>Parameters:</strong><table class="params"><thead><tr><th>Name</th><th>Type</th><th class="last">Description</th></tr></thead><tbody><tr><td class="name"><code>fct</code></td><td class="type"><span class="param-type">function</span></td><td class="description last"><p>The function to call in a microtask.</p></td></tr></tbody></table></div><dl class="details"><div class="details-item-container"><dt class="tag-source bold">Source</dt><dd class="tag-source"><ul><li><a href="queueMicrotask.mjs.html">queueMicrotask.mjs</a>, <a href="queueMicrotask.mjs.html#line17">line 17</a></li></ul></dd></div></dl><div class="method-member-container flex flex-col w-100 overflow-auto mt-20"><strong>Example</strong><div class="rel"><pre class="prettyprint"><code>import { queueMicrotask } from 'modern-async'

queueMicrotask(() => {
  console.log('this resolves in a micro task')
})</code></pre></div></div><h3 class="name has-anchor" id="reduce"><span class="type-signature">(async) </span>reduce<span class="signature">(iterable, reducer, initial<span class="signature-attributes">opt</span>)</span><span class="type-signature"> &rarr; {Promise}</span></h3><div class="description"><p>Performs a reduce operation as defined in the <code>Array.reduce()</code> method but using an asynchronous function as reducer. The reducer will be called sequentially.</p></div><div class="method-member-container flex flex-col w-100 overflow-auto mt-20"><strong>Parameters:</strong><table class="params"><thead><tr><th>Name</th><th>Type</th><th>Attributes</th><th class="last">Description</th></tr></thead><tbody><tr><td class="name"><code>iterable</code></td><td class="type"><span class="param-type">Iterable</span> |<wbr> <span class="param-type">AsyncIterable</span></td><td class="attributes"></td><td class="description last"><p>An iterable or async iterable object.</p></td></tr><tr><td class="name"><code>reducer</code></td><td class="type"><span class="param-type">function</span></td><td class="attributes"></td><td class="description last"><p>The reducer function. It will be called with four arguments:</p><ul><li><code>accumulator</code>: The last calculated value (or the first value of the iterable if no initial value is provided)</li><li><code>value</code>: The current value</li><li><code>index</code>: The current index in the iterable. Will start from 0 if no initial value is provided, 1 otherwise.</li><li><code>iterable</code>: The iterable on which the reduce operation is performed.</li></ul></td></tr><tr><td class="name"><code>initial</code></td><td class="type"><span class="param-type">any</span></td><td class="attributes">&lt;optional><br></td><td class="description last"><p>The initial value that will be used as accumulator in the first call to <code>reducer</code>. If omitted the first element of <code>iterable</code> will be used as accumulator and <code>reducer</code> will only be called from from the second element of the list (as defined in the <code>Array.reduce()</code> function).</p></td></tr></tbody></table></div><dl class="details"><div class="details-item-container"><dt class="tag-source bold">Source</dt><dd class="tag-source"><ul><li><a href="reduce.mjs.html">reduce.mjs</a>, <a href="reduce.mjs.html#line33">line 33</a></li></ul></dd></div></dl><div class="method-member-container mt-20"><strong>Returns:</strong><div class="param-desc"><p>A promise that will be resolved with the result of the reduce operation, or rejected if any of the calls to <code>reducer</code> throws an exception.</p></div><dl class="param-type"><dt>Type:&nbsp;</dt><dd><span class="param-type">Promise</span></dd></dl></div><div class="method-member-container flex flex-col w-100 overflow-auto mt-20"><strong>Example</strong><div class="rel"><pre class="prettyprint"><code>import { reduce, sleep } from 'modern-async'

const array = [1, 2, 3]
const result = await reduce(array, async (v, p) => {
  // these calls will be performed sequentially
  await sleep(10) // waits 10ms
  return v + p
})
console.log(result) // prints 6
// total processing time should be ~ 20ms</code></pre></div></div><h3 class="name has-anchor" id="reduceRight"><span class="type-signature">(async) </span>reduceRight<span class="signature">(iterable, reducer, initial<span class="signature-attributes">opt</span>)</span><span class="type-signature"> &rarr; {Promise}</span></h3><div class="description"><p>Performs a reduce operation as defined in the <code>Array.reduceRight()</code> method but using an asynchronous function as reducer. The reducer will be called sequentially.</p></div><div class="method-member-container flex flex-col w-100 overflow-auto mt-20"><strong>Parameters:</strong><table class="params"><thead><tr><th>Name</th><th>Type</th><th>Attributes</th><th class="last">Description</th></tr></thead><tbody><tr><td class="name"><code>iterable</code></td><td class="type"><span class="param-type">Iterable</span> |<wbr> <span class="param-type">AsyncIterable</span></td><td class="attributes"></td><td class="description last"><p>An iterable object.</p></td></tr><tr><td class="name"><code>reducer</code></td><td class="type"><span class="param-type">function</span></td><td class="attributes"></td><td class="description last"><p>The reducer function. It will be called with four arguments:</p><ul><li><code>accumulator</code>: The last calculated value (or the first value of the iterable if no initial value is provided)</li><li><code>value</code>: The current value</li><li><code>index</code>: The current index in the iterable. Will start from the last index if no initial value is provided, the last index minus 1 otherwise.</li><li><code>iterable</code>: The iterable on which the reduce operation is performed.</li></ul></td></tr><tr><td class="name"><code>initial</code></td><td class="type"><span class="param-type">any</span></td><td class="attributes">&lt;optional><br></td><td class="description last"><p>The initial value that will be used as accumulator in the first call to reducer. If omitted the first element of <code>iterable</code> will be used as accumulator and <code>reducer</code> will only be called from from the second element of the list (as defined in the <code>Array.reduce()</code> function).</p></td></tr></tbody></table></div><dl class="details"><div class="details-item-container"><dt class="tag-source bold">Source</dt><dd class="tag-source"><ul><li><a href="reduceRight.mjs.html">reduceRight.mjs</a>, <a href="reduceRight.mjs.html#line35">line 35</a></li></ul></dd></div></dl><div class="method-member-container mt-20"><strong>Returns:</strong><div class="param-desc"><p>A promise that will be resolved with the result of the reduce operation, or rejected if any of the calls to <code>reducer</code> throws an exception.</p></div><dl class="param-type"><dt>Type:&nbsp;</dt><dd><span class="param-type">Promise</span></dd></dl></div><div class="method-member-container flex flex-col w-100 overflow-auto mt-20"><strong>Example</strong><div class="rel"><pre class="prettyprint"><code>import { reduceRight, sleep } from 'modern-async'

const array = [1, 2, 3]
const result = await reduceRight(array, async (v, p) => {
  // these calls will be performed sequentially
  await sleep(10) // waits 10ms
  return v + p
})
console.log(result) // prints 6
// total processing time should be ~ 20ms</code></pre></div></div><h3 class="name has-anchor" id="sleep"><span class="type-signature">(async) </span>sleep<span class="signature">(amount)</span><span class="type-signature"> &rarr; {Promise.&lt;void>}</span></h3><div class="description"><p>Waits a given amount of time.</p><p>This function uses <code>setTimeout()</code> internally and has the same behavior, notably that it could resolve after the asked time (depending on other tasks running in the event loop) or a few milliseconds before.</p></div><div class="method-member-container flex flex-col w-100 overflow-auto mt-20"><strong>Parameters:</strong><table class="params"><thead><tr><th>Name</th><th>Type</th><th class="last">Description</th></tr></thead><tbody><tr><td class="name"><code>amount</code></td><td class="type"><span class="param-type">number</span></td><td class="description last"><p>An amount of time in milliseconds</p></td></tr></tbody></table></div><dl class="details"><div class="details-item-container"><dt class="tag-source bold">Source</dt><dd class="tag-source"><ul><li><a href="sleep.mjs.html">sleep.mjs</a>, <a href="sleep.mjs.html#line26">line 26</a></li></ul></dd></div></dl><div class="method-member-container mt-20"><strong>Returns:</strong><div class="param-desc"><p>A promise that will be resolved after the given amount of time has passed.</p></div><dl class="param-type"><dt>Type:&nbsp;</dt><dd><span class="param-type">Promise.&lt;void></span></dd></dl></div><div class="method-member-container flex flex-col w-100 overflow-auto mt-20"><strong>Examples</strong><div class="rel"><pre class="prettyprint"><code>import { sleep } from 'modern-async'

await sleep(100) // will wait 100ms</code></pre></div><div class="rel"><pre class="prettyprint"><code>// another example that doesn't block on the sleep call
// it's functionally identical to using setTimout but with a promise syntax
import { sleep } from 'modern-async'

sleep(10).then(() => {
  console.log('hello')
})
// will print 'hello' after 10ms</code></pre></div></div><h3 class="name has-anchor" id="sleepCancellable"><span class="type-signature"></span>sleepCancellable<span class="signature">(amount)</span><span class="type-signature"> &rarr; {Array}</span></h3><div class="description"><p>Waits a given amount of time. This function returns both a promise and cancel function in order to cancel the wait time if necessary. If cancelled, the promise will be rejected with a <code>CancelledError</code>.</p><p>This function uses <code>setTimeout()</code> internally and has the same behavior, notably that it could resolve after the asked time (depending on other tasks running in the event loop) or a few milliseconds before.</p></div><div class="method-member-container flex flex-col w-100 overflow-auto mt-20"><strong>Parameters:</strong><table class="params"><thead><tr><th>Name</th><th>Type</th><th class="last">Description</th></tr></thead><tbody><tr><td class="name"><code>amount</code></td><td class="type"><span class="param-type">number</span></td><td class="description last"><p>An amount of time in milliseconds</p></td></tr></tbody></table></div><dl class="details"><div class="details-item-container"><dt class="tag-source bold">Source</dt><dd class="tag-source"><ul><li><a href="sleepCancellable.mjs.html">sleepCancellable.mjs</a>, <a href="sleepCancellable.mjs.html#line32">line 32</a></li></ul></dd></div></dl><div class="method-member-container mt-20"><strong>Returns:</strong><div class="param-desc"><p>A tuple of two objects:</p><ul><li><code>promise</code>: The promise</li><li><code>cancel</code>: The cancel function. It will return a boolean that will be <code>true</code> if the promise was effectively cancelled, <code>false</code> otherwise.</li></ul></div><dl class="param-type"><dt>Type:&nbsp;</dt><dd><span class="param-type">Array</span></dd></dl></div><div class="method-member-container flex flex-col w-100 overflow-auto mt-20"><strong>Example</strong><div class="rel"><pre class="prettyprint"><code>import { sleepCancellable } from 'modern-async'

const [promise, cancel] = sleepCancellable(100) // schedule to resolve the promise after 100ms

cancel()

try {
  await promise
} catch (e) {
  console.log(e.name) // prints CancelledError
}</code></pre></div></div><h3 class="name has-anchor" id="sleepPrecise"><span class="type-signature">(async) </span>sleepPrecise<span class="signature">(amount)</span><span class="type-signature"> &rarr; {Promise.&lt;void>}</span></h3><div class="description"><p>Waits a given amount of time.</p><p>This function is similar to <code>sleep()</code> except it ensures that the amount of time measured using the <code>Date</code> object is always greater than or equal the asked amount of time.</p><p>This function can imply additional delay that can be bad for performances. As such it is recommended to only use it in unit tests or very specific cases. Most applications should be adapted to work with the usual <code>setTimout()</code> inconsistencies even if it can trigger some milliseconds before the asked delay.</p></div><div class="method-member-container flex flex-col w-100 overflow-auto mt-20"><strong>Parameters:</strong><table class="params"><thead><tr><th>Name</th><th>Type</th><th class="last">Description</th></tr></thead><tbody><tr><td class="name"><code>amount</code></td><td class="type"><span class="param-type">number</span></td><td class="description last"><p>An amount of time in milliseconds</p></td></tr></tbody></table></div><dl class="details"><div class="details-item-container"><dt class="tag-source bold">Source</dt><dd class="tag-source"><ul><li><a href="sleepPrecise.mjs.html">sleepPrecise.mjs</a>, <a href="sleepPrecise.mjs.html#line22">line 22</a></li></ul></dd></div></dl><div class="method-member-container mt-20"><strong>Returns:</strong><div class="param-desc"><p>A promise that will be resolved after the given amount of time has passed.</p></div><dl class="param-type"><dt>Type:&nbsp;</dt><dd><span class="param-type">Promise.&lt;void></span></dd></dl></div><div class="method-member-container flex flex-col w-100 overflow-auto mt-20"><strong>Example</strong><div class="rel"><pre class="prettyprint"><code>import { sleepPrecise } from 'modern-async'

await sleepPrecise(100) // will wait 100ms</code></pre></div></div><h3 class="name has-anchor" id="sleepPreciseCancellable"><span class="type-signature"></span>sleepPreciseCancellable<span class="signature">(amount)</span><span class="type-signature"> &rarr; {Array}</span></h3><div class="description"><p>Waits a given amount of time.</p><p>This function returns both a promise and cancel function in order to cancel the wait time if necessary. If cancelled, the promise will be rejected with a <code>CancelledError</code>.</p><p>This function is similar to <code>sleep()</code> except it ensures that the amount of time measured using the <code>Date</code> object is always greater than or equal the asked amount of time.</p><p>This function can imply additional delay that can be bad for performances. As such it is recommended to only use it in unit tests or very specific cases. Most applications should be adapted to work with the usual <code>setTimout()</code> inconsistencies even if it can trigger some milliseconds before the asked delay.</p></div><div class="method-member-container flex flex-col w-100 overflow-auto mt-20"><strong>Parameters:</strong><table class="params"><thead><tr><th>Name</th><th>Type</th><th class="last">Description</th></tr></thead><tbody><tr><td class="name"><code>amount</code></td><td class="type"><span class="param-type">number</span></td><td class="description last"><p>An amount of time in milliseconds</p></td></tr></tbody></table></div><dl class="details"><div class="details-item-container"><dt class="tag-source bold">Source</dt><dd class="tag-source"><ul><li><a href="sleepPreciseCancellable.mjs.html">sleepPreciseCancellable.mjs</a>, <a href="sleepPreciseCancellable.mjs.html#line38">line 38</a></li></ul></dd></div></dl><div class="method-member-container mt-20"><strong>Returns:</strong><div class="param-desc"><p>A tuple of two objects:</p><ul><li><code>promise</code>: The promise</li><li><code>cancel</code>: The cancel function. It will return a boolean that will be <code>true</code> if the promise was effectively cancelled, <code>false</code> otherwise.</li></ul></div><dl class="param-type"><dt>Type:&nbsp;</dt><dd><span class="param-type">Array</span></dd></dl></div><div class="method-member-container flex flex-col w-100 overflow-auto mt-20"><strong>Example</strong><div class="rel"><pre class="prettyprint"><code>import { sleepPreciseCancellable } from 'modern-async'

const [promise, cancel] = sleepPreciseCancellable(100) // schedule to resolve the promise after 100ms

cancel()

try {
  await promise
} catch (e) {
  console.log(e.name) // prints CancelledError
}</code></pre></div></div><h3 class="name has-anchor" id="some"><span class="type-signature">(async) </span>some<span class="signature">(iterable, iteratee)</span><span class="type-signature"> &rarr; {Promise.&lt;boolean>}</span></h3><div class="description"><p>Returns <code>true</code> if at least one element of an iterable pass a truth test and <code>false</code> otherwise.</p><p>The calls to <code>iteratee</code> will run in parallel. If any truth test returns <code>true</code> the promise is immediately resolved.</p><p>In case of exception in one of the <code>iteratee</code> calls the promise returned by this function will be rejected with the exception. In the very specific case where a test returns <code>true</code> and an already started task throws an exception that exception will be plainly ignored.</p></div><div class="method-member-container flex flex-col w-100 overflow-auto mt-20"><strong>Parameters:</strong><table class="params"><thead><tr><th>Name</th><th>Type</th><th class="last">Description</th></tr></thead><tbody><tr><td class="name"><code>iterable</code></td><td class="type"><span class="param-type">Iterable</span> |<wbr> <span class="param-type">AsyncIterable</span></td><td class="description last"><p>An iterable or async iterable object.</p></td></tr><tr><td class="name"><code>iteratee</code></td><td class="type"><span class="param-type">function</span></td><td class="description last"><p>A function that will be called with each member of the iterable. It will receive three arguments:</p><ul><li><code>value</code>: The current value to process</li><li><code>index</code>: The index in the iterable. Will start from 0.</li><li><code>iterable</code>: The iterable on which the operation is being performed.</li></ul></td></tr></tbody></table></div><dl class="details"><div class="details-item-container"><dt class="tag-source bold">Source</dt><dd class="tag-source"><ul><li><a href="some.mjs.html">some.mjs</a>, <a href="some.mjs.html#line34">line 34</a></li></ul></dd></div></dl><div class="method-member-container mt-20"><strong>Returns:</strong><div class="param-desc"><p>A promise that will be resolved to <code>true</code> if at least one value pass the truth test and <code>false</code> if none of them do. That promise will be rejected if one of the truth test throws an exception.</p></div><dl class="param-type"><dt>Type:&nbsp;</dt><dd><span class="param-type">Promise.&lt;boolean></span></dd></dl></div><div class="method-member-container flex flex-col w-100 overflow-auto mt-20"><strong>Example</strong><div class="rel"><pre class="prettyprint"><code>import { some, sleep } from 'modern-async'

const array = [1, 2, 3]

const result = await some(array, async (v) => {
  // these calls will be performed in parallel
  await sleep(10) // waits 10ms
  return v % 2 === 0
})
console.log(result) // prints true
// total processing time should be ~ 10ms</code></pre></div></div><h3 class="name has-anchor" id="someLimit"><span class="type-signature">(async) </span>someLimit<span class="signature">(iterable, iteratee, queueOrConcurrency)</span><span class="type-signature"> &rarr; {Promise.&lt;boolean>}</span></h3><div class="description"><p>Returns <code>true</code> if at least one element of an iterable pass a truth test and <code>false</code> otherwise.</p><p>The calls to <code>iteratee</code> will be performed in a queue to limit the concurrency of these calls. If any truth test returns <code>true</code> the promise is immediately resolved.</p><p>Whenever a test returns <code>true</code>, all the remaining tasks will be cancelled as long as they didn't started already. In case of exception in one of the <code>iteratee</code> calls the promise returned by this function will be rejected with the exception and the remaining pending tasks will also be cancelled. In the very specific case where a test returns <code>true</code> and an already started task throws an exception that exception will be plainly ignored.</p></div><div class="method-member-container flex flex-col w-100 overflow-auto mt-20"><strong>Parameters:</strong><table class="params"><thead><tr><th>Name</th><th>Type</th><th class="last">Description</th></tr></thead><tbody><tr><td class="name"><code>iterable</code></td><td class="type"><span class="param-type">Iterable</span> |<wbr> <span class="param-type">AsyncIterable</span></td><td class="description last"><p>An iterable or async iterable object.</p></td></tr><tr><td class="name"><code>iteratee</code></td><td class="type"><span class="param-type">function</span></td><td class="description last"><p>A function that will be called with each member of the iterable. It will receive three arguments:</p><ul><li><code>value</code>: The current value to process</li><li><code>index</code>: The index in the iterable. Will start from 0.</li><li><code>iterable</code>: The iterable on which the operation is being performed.</li></ul></td></tr><tr><td class="name"><code>queueOrConcurrency</code></td><td class="type"><span class="param-type"><a href="Queue.html">Queue</a></span> |<wbr> <span class="param-type">number</span></td><td class="description last"><p>If a queue is specified it will be used to schedule the calls to <code>iteratee</code>. If a number is specified it will be used as the concurrency of a Queue that will be created implicitly for the same purpose.</p></td></tr></tbody></table></div><dl class="details"><div class="details-item-container"><dt class="tag-source bold">Source</dt><dd class="tag-source"><ul><li><a href="someLimit.mjs.html">someLimit.mjs</a>, <a href="someLimit.mjs.html#line42">line 42</a></li></ul></dd></div></dl><div class="method-member-container mt-20"><strong>Returns:</strong><div class="param-desc"><p>A promise that will be resolved to <code>true</code> if at least one value pass the truth test and <code>false</code> if none of them do. That promise will be rejected if one of the truth test throws an exception.</p></div><dl class="param-type"><dt>Type:&nbsp;</dt><dd><span class="param-type">Promise.&lt;boolean></span></dd></dl></div><div class="method-member-container flex flex-col w-100 overflow-auto mt-20"><strong>Example</strong><div class="rel"><pre class="prettyprint"><code>import { someLimit, sleep } from 'modern-async'

const array = [1, 2, 3]

const result = await someLimit(array, async (v) => {
  // these calls will be performed in parallel with a maximum of 2
  // concurrent calls
  await sleep(10) // waits 10ms
  return v % 2 === 0
}, 2)
console.log(result) // prints true
// total processing time should be ~ 10ms</code></pre></div></div><h3 class="name has-anchor" id="someSeries"><span class="type-signature">(async) </span>someSeries<span class="signature">(iterable, iteratee)</span><span class="type-signature"> &rarr; {Promise.&lt;boolean>}</span></h3><div class="description"><p>Returns <code>true</code> if all elements of an iterable pass a truth test and <code>false</code> otherwise.</p><p>The calls to <code>iteratee</code> will run sequentially. If any truth test returns <code>true</code> the promise is immediately resolved.</p><p>In case of exception in one of the iteratee calls the promise returned by this function will be rejected with the exception and the remaining pending tasks will be cancelled.</p></div><div class="method-member-container flex flex-col w-100 overflow-auto mt-20"><strong>Parameters:</strong><table class="params"><thead><tr><th>Name</th><th>Type</th><th class="last">Description</th></tr></thead><tbody><tr><td class="name"><code>iterable</code></td><td class="type"><span class="param-type">Iterable</span> |<wbr> <span class="param-type">AsyncIterable</span></td><td class="description last"><p>An iterable or async iterable object.</p></td></tr><tr><td class="name"><code>iteratee</code></td><td class="type"><span class="param-type">function</span></td><td class="description last"><p>A function that will be called with each member of the iterable. It will receive three arguments:</p><ul><li><code>value</code>: The current value to process</li><li><code>index</code>: The index in the iterable. Will start from 0.</li><li><code>iterable</code>: The iterable on which the operation is being performed.</li></ul></td></tr></tbody></table></div><dl class="details"><div class="details-item-container"><dt class="tag-source bold">Source</dt><dd class="tag-source"><ul><li><a href="someSeries.mjs.html">someSeries.mjs</a>, <a href="someSeries.mjs.html#line34">line 34</a></li></ul></dd></div></dl><div class="method-member-container mt-20"><strong>Returns:</strong><div class="param-desc"><p>A promise that will be resolved to <code>true</code> if at least one value pass the truth test and <code>false</code> if none of them do. That promise will be rejected if one of the truth test throws an exception.</p></div><dl class="param-type"><dt>Type:&nbsp;</dt><dd><span class="param-type">Promise.&lt;boolean></span></dd></dl></div><div class="method-member-container flex flex-col w-100 overflow-auto mt-20"><strong>Example</strong><div class="rel"><pre class="prettyprint"><code>import { someSeries, sleep } from 'modern-async'

const array = [1, 2, 3]

const result = await someSeries(array, async (v) => {
  // these calls will be performed sequentially
  await sleep(10) // waits 10ms
  return v % 2 === 0
})
console.log(result) // prints true
// total processing time should be ~ 20ms</code></pre></div></div><h3 class="name has-anchor" id="timeout"><span class="type-signature">(async) </span>timeout<span class="signature">(fct, amount)</span><span class="type-signature"> &rarr; {Promise}</span></h3><div class="description"><p>Wraps a call to an asynchronous function to add a timer on it. If the delay is exceeded the returned promise will be rejected with a <code>TimeoutError</code>.</p><p>This function uses <code>setTimeout()</code> internally and has the same behavior, notably that it could reject after the asked time (depending on other tasks running in the event loop) or a few milliseconds before.</p></div><div class="method-member-container flex flex-col w-100 overflow-auto mt-20"><strong>Parameters:</strong><table class="params"><thead><tr><th>Name</th><th>Type</th><th class="last">Description</th></tr></thead><tbody><tr><td class="name"><code>fct</code></td><td class="type"><span class="param-type">function</span></td><td class="description last"><p>An asynchronous function that will be called immediately without arguments.</p></td></tr><tr><td class="name"><code>amount</code></td><td class="type"><span class="param-type">number</span></td><td class="description last"><p>An amount of time in milliseconds</p></td></tr></tbody></table></div><dl class="details"><div class="details-item-container"><dt class="tag-source bold">Source</dt><dd class="tag-source"><ul><li><a href="timeout.mjs.html">timeout.mjs</a>, <a href="timeout.mjs.html#line37">line 37</a></li></ul></dd></div></dl><div class="method-member-container mt-20"><strong>Returns:</strong><div class="param-desc"><p>A promise that will be resolved or rejected according to the result of the call to <code>fct</code>. If <code>amount</code> milliseconds pass before the call to <code>fct</code> returns or rejects, this promise will be rejected with a <code>TimeoutError</code>.</p></div><dl class="param-type"><dt>Type:&nbsp;</dt><dd><span class="param-type">Promise</span></dd></dl></div><div class="method-member-container flex flex-col w-100 overflow-auto mt-20"><strong>Example</strong><div class="rel"><pre class="prettyprint"><code>import { timeout, sleep } from 'modern-async'

// the following statement will perform successfully because
// the function will return before the delay
await timeout(async () => {
  await sleep(10)
}, 100)

try {
  // the following statement will throw after 10ms
  await timeout(async () => {
    await sleep(100)
  }, 10)
} catch (e) {
  console.log(e.name) // prints TimeoutError
}</code></pre></div></div><h3 class="name has-anchor" id="timeoutPrecise"><span class="type-signature">(async) </span>timeoutPrecise<span class="signature">(fct, amount)</span><span class="type-signature"> &rarr; {Promise}</span></h3><div class="description"><p>Wraps a call to an asynchronous function to add a timer on it. If the delay is exceeded the returned promise will be rejected with a <code>TimeoutError</code>.</p><p>This function is similar to <code>timeout()</code> except it ensures that the amount of time measured using the <code>Date</code> object is always greater than or equal the asked amount of time.</p><p>This function can imply additional delay that can be bad for performances. As such it is recommended to only use it in unit tests or very specific cases. Most applications should be adapted to work with the usual <code>setTimout()</code> inconsistencies even if it can trigger some milliseconds before the asked delay.</p></div><div class="method-member-container flex flex-col w-100 overflow-auto mt-20"><strong>Parameters:</strong><table class="params"><thead><tr><th>Name</th><th>Type</th><th class="last">Description</th></tr></thead><tbody><tr><td class="name"><code>fct</code></td><td class="type"><span class="param-type">function</span></td><td class="description last"><p>An asynchronous function that will be called immediately without arguments.</p></td></tr><tr><td class="name"><code>amount</code></td><td class="type"><span class="param-type">number</span></td><td class="description last"><p>An amount of time in milliseconds</p></td></tr></tbody></table></div><dl class="details"><div class="details-item-container"><dt class="tag-source bold">Source</dt><dd class="tag-source"><ul><li><a href="timeoutPrecise.mjs.html">timeoutPrecise.mjs</a>, <a href="timeoutPrecise.mjs.html#line42">line 42</a></li></ul></dd></div></dl><div class="method-member-container mt-20"><strong>Returns:</strong><div class="param-desc"><p>A promise that will be resolved or rejected according to the result of the call to <code>fct</code>. If <code>amount</code> milliseconds pass before the call to <code>fct</code> returns or rejects, this promise will be rejected with a <code>TimeoutError</code>.</p></div><dl class="param-type"><dt>Type:&nbsp;</dt><dd><span class="param-type">Promise</span></dd></dl></div><div class="method-member-container flex flex-col w-100 overflow-auto mt-20"><strong>Example</strong><div class="rel"><pre class="prettyprint"><code>import { timeoutPrecise, sleep } from 'modern-async'

// the following statement will perform successfully because
// the function will return before the delay
await timeoutPrecise(async () => {
  await sleep(10)
}, 100)

try {
  // the following statement will throw after 10ms
  await timeoutPrecise(async () => {
    await sleep(100)
  }, 10)
} catch (e) {
  console.log(e.name) // prints TimeoutError
}</code></pre></div></div><h3 class="name has-anchor" id="toArray"><span class="type-signature">(async) </span>toArray<span class="signature">(iterable)</span><span class="type-signature"> &rarr; {Promise.&lt;Array.&lt;any>>}</span></h3><div class="description"><p>Fully consumes an iteratable or async iterable an returns an array with all the elements it contained.</p></div><div class="method-member-container flex flex-col w-100 overflow-auto mt-20"><strong>Parameters:</strong><table class="params"><thead><tr><th>Name</th><th>Type</th><th class="last">Description</th></tr></thead><tbody><tr><td class="name"><code>iterable</code></td><td class="type"><span class="param-type">Iterable</span> |<wbr> <span class="param-type">AsyncIterable</span></td><td class="description last"><p>An iterator or async iterator.</p></td></tr></tbody></table></div><dl class="details"><div class="details-item-container"><dt class="tag-source bold">Source</dt><dd class="tag-source"><ul><li><a href="toArray.mjs.html">toArray.mjs</a>, <a href="toArray.mjs.html#line23">line 23</a></li></ul></dd></div></dl><div class="method-member-container mt-20"><strong>Returns:</strong><div class="param-desc"><p>An array.</p></div><dl class="param-type"><dt>Type:&nbsp;</dt><dd><span class="param-type">Promise.&lt;Array.&lt;any>></span></dd></dl></div><div class="method-member-container flex flex-col w-100 overflow-auto mt-20"><strong>Example</strong><div class="rel"><pre class="prettyprint"><code>import { toArray, sleep } from 'modern-async'

// example async generator
async function* asyncGenerator() {
  for (let i = 0; i &lt; 3; i += 1) {
    await sleep(10)
    yield i
  }
}

console.log(await toArray(asyncGenerator()))
// prints [0, 1, 2]</code></pre></div></div></article></section><footer class="footer" id="PeOAagUepe"><div class="wrapper">modern-async is licensed under the terms of the MIT license</div></footer></div></div></div><div class="search-container" id="PkfLWpAbet" style="display:none"><div class="wrapper" id="iCxFxjkHbP"><button class="icon-button search-close-button" id="VjLlGakifb" aria-label="close search"><svg><use xlink:href="#close-icon"></use></svg></button><div class="search-box-c"><svg><use xlink:href="#search-icon"></use></svg> <input type="text" id="vpcKVYIppa" class="search-input" placeholder="Search..." autofocus></div><div class="search-result-c" id="fWwVHRuDuN"><span class="search-result-c-text">Type anything to view search result</span></div></div></div><div class="mobile-menu-icon-container"><button class="icon-button" id="mobile-menu" data-isopen="false" aria-label="menu"><svg><use xlink:href="#menu-icon"></use></svg></button></div><div id="mobile-sidebar" class="mobile-sidebar-container"><div class="mobile-sidebar-wrapper"><a href="/" class="sidebar-title sidebar-title-anchor">modern-async</a><div class="mobile-nav-links"><div class="navbar-item"><a id="" href="https://github.com/nicolas-van/modern-async" target="">Github</a></div></div><div class="mobile-sidebar-items-c"><div class="sidebar-section-title with-arrow" data-isopen="false" id="bqr_fCmM1c_Z4NxD1P5CB"><div>Classes</div><svg><use xlink:href="#down-icon"></use></svg></div><div class="sidebar-section-children-container"><div class="sidebar-section-children"><a href="CancelledError.html">CancelledError</a></div><div class="sidebar-section-children"><a href="Deferred.html">Deferred</a></div><div class="sidebar-section-children"><a href="Delayer.html">Delayer</a></div><div class="sidebar-section-children"><a href="Queue.html">Queue</a></div><div class="sidebar-section-children"><a href="Scheduler.html">Scheduler</a></div><div class="sidebar-section-children"><a href="TimeoutError.html">TimeoutError</a></div></div><div class="sidebar-section-title with-arrow" data-isopen="false" id="y--SulyMBf_mP5QBQSbgu"><div>Global</div><svg><use xlink:href="#down-icon"></use></svg></div><div class="sidebar-section-children-container"><div class="sidebar-section-children"><a href="global.html#asyncIterableWrap">asyncIterableWrap</a></div><div class="sidebar-section-children"><a href="global.html#asyncRoot">asyncRoot</a></div><div class="sidebar-section-children"><a href="global.html#asyncWrap">asyncWrap</a></div><div class="sidebar-section-children"><a href="global.html#delay">delay</a></div><div class="sidebar-section-children"><a href="global.html#delayCancellable">delayCancellable</a></div><div class="sidebar-section-children"><a href="global.html#every">every</a></div><div class="sidebar-section-children"><a href="global.html#everyLimit">everyLimit</a></div><div class="sidebar-section-children"><a href="global.html#everySeries">everySeries</a></div><div class="sidebar-section-children"><a href="global.html#filter">filter</a></div><div class="sidebar-section-children"><a href="global.html#filterGenerator">filterGenerator</a></div><div class="sidebar-section-children"><a href="global.html#filterLimit">filterLimit</a></div><div class="sidebar-section-children"><a href="global.html#filterSeries">filterSeries</a></div><div class="sidebar-section-children"><a href="global.html#find">find</a></div><div class="sidebar-section-children"><a href="global.html#findIndex">findIndex</a></div><div class="sidebar-section-children"><a href="global.html#findIndexLimit">findIndexLimit</a></div><div class="sidebar-section-children"><a href="global.html#findIndexSeries">findIndexSeries</a></div><div class="sidebar-section-children"><a href="global.html#findLimit">findLimit</a></div><div class="sidebar-section-children"><a href="global.html#findSeries">findSeries</a></div><div class="sidebar-section-children"><a href="global.html#forEach">forEach</a></div><div class="sidebar-section-children"><a href="global.html#forEachLimit">forEachLimit</a></div><div class="sidebar-section-children"><a href="global.html#forEachSeries">forEachSeries</a></div><div class="sidebar-section-children"><a href="global.html#map">map</a></div><div class="sidebar-section-children"><a href="global.html#mapGenerator">mapGenerator</a></div><div class="sidebar-section-children"><a href="global.html#mapLimit">mapLimit</a></div><div class="sidebar-section-children"><a href="global.html#mapSeries">mapSeries</a></div><div class="sidebar-section-children"><a href="global.html#queueMicrotask">queueMicrotask</a></div><div class="sidebar-section-children"><a href="global.html#reduce">reduce</a></div><div class="sidebar-section-children"><a href="global.html#reduceRight">reduceRight</a></div><div class="sidebar-section-children"><a href="global.html#sleep">sleep</a></div><div class="sidebar-section-children"><a href="global.html#sleepCancellable">sleepCancellable</a></div><div class="sidebar-section-children"><a href="global.html#sleepPrecise">sleepPrecise</a></div><div class="sidebar-section-children"><a href="global.html#sleepPreciseCancellable">sleepPreciseCancellable</a></div><div class="sidebar-section-children"><a href="global.html#some">some</a></div><div class="sidebar-section-children"><a href="global.html#someLimit">someLimit</a></div><div class="sidebar-section-children"><a href="global.html#someSeries">someSeries</a></div><div class="sidebar-section-children"><a href="global.html#timeout">timeout</a></div><div class="sidebar-section-children"><a href="global.html#timeoutPrecise">timeoutPrecise</a></div><div class="sidebar-section-children"><a href="global.html#toArray">toArray</a></div></div></div><div class="mobile-navbar-actions"><div class="navbar-right-item"><button class="icon-button search-button" aria-label="open-search"><svg><use xlink:href="#search-icon"></use></svg></button></div><div class="navbar-right-item"><button class="icon-button theme-toggle" aria-label="toggle-theme"><svg><use class="theme-svg-use" xlink:href="#light-theme-icon"></use></svg></button></div><div class="navbar-right-item"><button class="icon-button font-size" aria-label="change-font-size"><svg><use xlink:href="#font-size-icon"></use></svg></button></div></div></div></div><script type="text/javascript" src="scripts/core.min.js"></script><script src="scripts/search.min.js" defer="defer"></script><script src="scripts/third-party/fuse.js" defer="defer"></script><script type="text/javascript">var tocbotInstance=tocbot.init({tocSelector:"#eed4d2a0bfd64539bb9df78095dec881",contentSelector:".main-content",headingSelector:"h1, h2, h3",hasInnerContainers:!0,scrollContainer:".main-content",headingsOffset:130,onClick:bringLinkToView})</script></body></html>